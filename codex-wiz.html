<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="ai.author" content="ChatGPT-5.3-Codex">
  <meta name="ai.note" content="This file was generated by ChatGPT-5.3-Codex.">
  <title>Wizardry Dungeon - ChatGPT-5.3-Codex</title>
  <style>
    :root {
      --bg: #070912;
      --panel: #0f1527;
      --line: #2d3a62;
      --text: #dce6ff;
      --muted: #8fa0c8;
      --accent: #79d5ff;
      --warn: #ffc477;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background:
        radial-gradient(circle at 15% 12%, rgba(121, 213, 255, 0.20), transparent 35%),
        radial-gradient(circle at 90% 10%, rgba(255, 141, 109, 0.15), transparent 33%),
        var(--bg);
      color: var(--text);
      font-family: "Segoe UI", sans-serif;
    }
    .app {
      width: min(980px, 96vw);
      display: grid;
      grid-template-columns: 1fr 250px;
      gap: 14px;
      align-items: start;
    }
    .view {
      position: relative;
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow: hidden;
      background: #050811;
    }
    canvas {
      display: block;
      width: 100%;
      height: auto;
      aspect-ratio: 16 / 9;
    }
    .panel {
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 12px;
    }
    .title {
      margin: 0 0 8px;
      color: var(--accent);
      font-size: 16px;
      letter-spacing: 0.04em;
    }
    .stat { font-size: 14px; margin: 5px 0; color: var(--muted); }
    .stat b { color: var(--text); }
    .msg {
      margin-top: 10px;
      min-height: 52px;
      font-size: 13px;
      color: #bfd3ff;
      line-height: 1.5;
      border-top: 1px solid var(--line);
      padding-top: 8px;
    }
    .kbd {
      margin-top: 10px;
      border-top: 1px solid var(--line);
      padding-top: 8px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.6;
    }
    .overlay {
      position: absolute;
      inset: 0;
      display: none;
      place-items: center;
      background: rgba(3, 5, 12, 0.78);
      backdrop-filter: blur(2px);
    }
    .overlay.active { display: grid; }
    .dialog {
      width: min(420px, 92%);
      background: #0e162a;
      border: 1px solid #314470;
      border-radius: 12px;
      padding: 14px;
    }
    .dialog h2 {
      margin: 0 0 10px;
      font-size: 18px;
      color: var(--warn);
    }
    .dialog p {
      margin: 7px 0;
      font-size: 14px;
      color: #c9d8fb;
      line-height: 1.5;
    }
    .actions {
      margin-top: 12px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    button {
      border: 1px solid #3a4f7f;
      background: #162344;
      color: #e6efff;
      padding: 8px 12px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
    }
    button:hover { background: #1b2c55; }
    .mobile {
      display: none;
      margin-top: 10px;
      grid-template-columns: repeat(3, 56px);
      gap: 8px;
      justify-content: center;
    }
    .mobile button {
      width: 56px;
      height: 42px;
      padding: 0;
      font-size: 16px;
      font-weight: 700;
    }
    .mobile .wide { grid-column: span 3; }
    @media (max-width: 900px) {
      .app { grid-template-columns: 1fr; }
      .mobile { display: grid; }
    }
  </style>
</head>
<body>
  <main class="app">
    <section class="view">
      <canvas id="game" width="960" height="540"></canvas>
      <div class="overlay" id="battle-overlay">
        <div class="dialog">
          <h2 id="battle-title">ENCOUNTER</h2>
          <p id="battle-text"></p>
          <p id="battle-enemy"></p>
          <div class="actions">
            <button id="btn-attack">Attack</button>
            <button id="btn-guard">Guard</button>
            <button id="btn-flee">Flee</button>
          </div>
        </div>
      </div>
      <div class="overlay" id="end-overlay">
        <div class="dialog">
          <h2 id="end-title">GAME OVER</h2>
          <p id="end-text"></p>
          <div class="actions">
            <button id="btn-restart">Restart</button>
          </div>
        </div>
      </div>
    </section>

    <aside class="panel">
      <h1 class="title">WIZARDRY DUNGEON</h1>
      <div class="stat">Floor: <b id="s-floor">1</b></div>
      <div class="stat">HP: <b id="s-hp">30</b></div>
      <div class="stat">ATK: <b id="s-atk">6</b></div>
      <div class="stat">Steps: <b id="s-steps">0</b></div>
      <div class="stat">Wins: <b id="s-wins">0</b></div>
      <div class="msg" id="msg">地下迷宮へようこそ。階段を探してください。</div>
      <div class="kbd">
        <div>Move: W/S or ↑/↓</div>
        <div>Turn: A/D or ←/→</div>
        <div>Strafe: Q/E</div>
        <div>Enter stair: Enter</div>
      </div>
      <div class="mobile">
        <button data-act="turnLeft">⟲</button>
        <button data-act="forward">↑</button>
        <button data-act="turnRight">⟳</button>
        <button data-act="strafeLeft">◀</button>
        <button data-act="backward">↓</button>
        <button data-act="strafeRight">▶</button>
        <button class="wide" data-act="use">ENTER STAIR</button>
      </div>
    </aside>
  </main>

  <script>
    const CELL_EMPTY = 0;
    const CELL_WALL = 1;
    const CELL_STAIR = 2;
    const MAP_W = 23;
    const MAP_H = 23;

    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const battleOverlay = document.getElementById("battle-overlay");
    const endOverlay = document.getElementById("end-overlay");
    const battleText = document.getElementById("battle-text");
    const battleEnemy = document.getElementById("battle-enemy");
    const msg = document.getElementById("msg");

    const state = {
      floor: 1,
      hp: 30,
      atk: 6,
      steps: 0,
      wins: 0,
      map: [],
      player: { x: 1.5, y: 1.5, a: 0 },
      enemy: null,
      guard: false,
      inBattle: false,
      over: false
    };

    const keys = new Set();
    const FOV = Math.PI / 3;
    const MAX_DIST = 22;

    function setMsg(text) {
      msg.textContent = text;
    }

    function setStats() {
      document.getElementById("s-floor").textContent = String(state.floor);
      document.getElementById("s-hp").textContent = String(Math.max(0, state.hp));
      document.getElementById("s-atk").textContent = String(state.atk);
      document.getElementById("s-steps").textContent = String(state.steps);
      document.getElementById("s-wins").textContent = String(state.wins);
    }

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    function mapAt(x, y) {
      const gx = Math.floor(x);
      const gy = Math.floor(y);
      if (gx < 0 || gy < 0 || gx >= MAP_W || gy >= MAP_H) return CELL_WALL;
      return state.map[gy][gx];
    }

    function buildFloor() {
      const map = Array.from({ length: MAP_H }, () => Array(MAP_W).fill(CELL_WALL));
      let x = 1;
      let y = 1;
      map[y][x] = CELL_EMPTY;

      const dirs = [[1,0], [-1,0], [0,1], [0,-1]];
      const targetCarve = 260 + state.floor * 12;
      for (let i = 0; i < targetCarve; i++) {
        const d = dirs[(Math.random() * dirs.length) | 0];
        x = Math.max(1, Math.min(MAP_W - 2, x + d[0]));
        y = Math.max(1, Math.min(MAP_H - 2, y + d[1]));
        map[y][x] = CELL_EMPTY;
        if (Math.random() < 0.33) {
          const sx = Math.max(1, Math.min(MAP_W - 2, x + d[1]));
          const sy = Math.max(1, Math.min(MAP_H - 2, y + d[0]));
          map[sy][sx] = CELL_EMPTY;
        }
      }

      let far = { x: 1, y: 1, d: -1 };
      for (let yy = 1; yy < MAP_H - 1; yy++) {
        for (let xx = 1; xx < MAP_W - 1; xx++) {
          if (map[yy][xx] !== CELL_EMPTY) continue;
          const d = (xx - 1) * (xx - 1) + (yy - 1) * (yy - 1);
          if (d > far.d) far = { x: xx, y: yy, d };
        }
      }
      map[far.y][far.x] = CELL_STAIR;
      state.map = map;
      state.player.x = 1.5;
      state.player.y = 1.5;
      state.player.a = 0;
      setMsg("階段を探せ。敵との遭遇に注意。");
    }

    function tryMove(dx, dy) {
      if (state.inBattle || state.over) return false;
      const nx = state.player.x + dx;
      const ny = state.player.y + dy;
      if (mapAt(nx, ny) === CELL_WALL) return false;
      state.player.x = nx;
      state.player.y = ny;
      state.steps++;
      setStats();
      const cell = mapAt(state.player.x, state.player.y);
      if (cell === CELL_STAIR) {
        setMsg("階段を発見。Enterで次の階層へ。");
      } else {
        rollEncounter();
      }
      return true;
    }

    function forwardVec() {
      return { x: Math.cos(state.player.a), y: Math.sin(state.player.a) };
    }

    function rightVec() {
      return { x: Math.cos(state.player.a + Math.PI / 2), y: Math.sin(state.player.a + Math.PI / 2) };
    }

    function startEncounter() {
      state.inBattle = true;
      state.guard = false;
      const hp = randInt(8, 12) + state.floor * 2;
      const atk = randInt(2, 4) + Math.floor(state.floor / 2);
      state.enemy = { hp, atk };
      battleOverlay.classList.add("active");
      battleText.textContent = "敵が現れた。どうする？";
      battleEnemy.textContent = `Enemy HP ${state.enemy.hp} / ATK ${state.enemy.atk}`;
      setMsg("戦闘中...");
    }

    function endEncounter(win) {
      state.inBattle = false;
      state.guard = false;
      battleOverlay.classList.remove("active");
      if (win) {
        state.wins++;
        if (state.wins % 3 === 0) state.atk++;
        state.hp = Math.min(30 + state.floor * 2, state.hp + 2);
        setMsg("勝利。先へ進もう。");
      }
      setStats();
      state.enemy = null;
    }

    function enemyTurn() {
      if (!state.enemy) return;
      const base = randInt(0, 2);
      let damage = state.enemy.atk + base;
      if (state.guard) damage = Math.max(1, Math.floor(damage * 0.5));
      state.guard = false;
      state.hp -= damage;
      if (state.hp <= 0) {
        state.hp = 0;
        setStats();
        state.over = true;
        battleOverlay.classList.remove("active");
        document.getElementById("end-title").textContent = "GAME OVER";
        document.getElementById("end-text").textContent = `${state.floor}階で倒れた。もう一度挑戦する。`;
        endOverlay.classList.add("active");
        return;
      }
      battleText.textContent = `敵の攻撃 ${damage} ダメージ。`;
      battleEnemy.textContent = `Enemy HP ${state.enemy.hp} / ATK ${state.enemy.atk}`;
      setStats();
    }

    function attack() {
      if (!state.inBattle || !state.enemy) return;
      const damage = state.atk + randInt(0, 3);
      state.enemy.hp -= damage;
      battleText.textContent = `攻撃 ${damage} ダメージ。`;
      if (state.enemy.hp <= 0) {
        endEncounter(true);
        return;
      }
      enemyTurn();
    }

    function guard() {
      if (!state.inBattle || !state.enemy) return;
      state.guard = true;
      battleText.textContent = "防御態勢。被ダメージ半減。";
      enemyTurn();
    }

    function flee() {
      if (!state.inBattle || !state.enemy) return;
      const ok = Math.random() < 0.45;
      if (ok) {
        setMsg("逃走成功。");
        endEncounter(false);
      } else {
        battleText.textContent = "逃走失敗。";
        enemyTurn();
      }
    }

    function rollEncounter() {
      const chance = 0.11 + Math.min(0.14, state.floor * 0.01);
      if (Math.random() < chance) startEncounter();
    }

    function useTile() {
      if (state.inBattle || state.over) return;
      if (mapAt(state.player.x, state.player.y) !== CELL_STAIR) {
        setMsg("ここには何もない。");
        return;
      }
      state.floor++;
      buildFloor();
      setStats();
    }

    function castRay(ang) {
      let dist = 0;
      let hit = CELL_WALL;
      let side = 0;
      let x = state.player.x;
      let y = state.player.y;
      while (dist < MAX_DIST) {
        const step = 0.02;
        x += Math.cos(ang) * step;
        y += Math.sin(ang) * step;
        dist += step;
        const cell = mapAt(x, y);
        if (cell !== CELL_EMPTY) {
          hit = cell;
          const fx = x - Math.floor(x);
          const fy = y - Math.floor(y);
          side = (fx < 0.03 || fx > 0.97) ? 1 : ((fy < 0.03 || fy > 0.97) ? 2 : 0);
          break;
        }
      }
      return { dist, hit, side };
    }

    function drawWorld() {
      const w = canvas.width;
      const h = canvas.height;
      const cx = w * 0.5;
      const cy = h * 0.5;

      const sky = ctx.createLinearGradient(0, 0, 0, cy);
      sky.addColorStop(0, "#12214d");
      sky.addColorStop(1, "#0a132a");
      ctx.fillStyle = sky;
      ctx.fillRect(0, 0, w, cy);

      const floor = ctx.createLinearGradient(0, cy, 0, h);
      floor.addColorStop(0, "#0d1018");
      floor.addColorStop(1, "#05070d");
      ctx.fillStyle = floor;
      ctx.fillRect(0, cy, w, h - cy);

      for (let x = 0; x < w; x++) {
        const ray = (state.player.a - FOV * 0.5) + (x / w) * FOV;
        const info = castRay(ray);
        const corrected = Math.max(0.0001, info.dist * Math.cos(ray - state.player.a));
        const wallH = Math.min(h * 1.5, h / corrected);
        const y1 = (h - wallH) * 0.5;

        let c = "#7894d8";
        if (info.hit === CELL_STAIR) c = "#f8cf7d";
        const fog = Math.max(0, 1 - corrected / MAX_DIST);
        const shade = info.side === 0 ? 1 : (info.side === 1 ? 0.82 : 0.68);
        const r = Math.floor(parseInt(c.slice(1, 3), 16) * fog * shade);
        const g = Math.floor(parseInt(c.slice(3, 5), 16) * fog * shade);
        const b = Math.floor(parseInt(c.slice(5, 7), 16) * fog * shade);
        ctx.fillStyle = `rgb(${r},${g},${b})`;
        ctx.fillRect(x, y1, 1, wallH);
      }

      ctx.strokeStyle = "rgba(220,230,255,0.2)";
      ctx.beginPath();
      ctx.moveTo(cx - 8, cy);
      ctx.lineTo(cx + 8, cy);
      ctx.moveTo(cx, cy - 8);
      ctx.lineTo(cx, cy + 8);
      ctx.stroke();
    }

    function drawMiniMap() {
      const size = 150;
      const tile = size / MAP_W;
      const px = 12;
      const py = 12;
      ctx.fillStyle = "rgba(4,6,12,0.78)";
      ctx.fillRect(px - 2, py - 2, size + 4, size + 4);

      for (let y = 0; y < MAP_H; y++) {
        for (let x = 0; x < MAP_W; x++) {
          const v = state.map[y][x];
          if (v === CELL_WALL) ctx.fillStyle = "#233355";
          else if (v === CELL_STAIR) ctx.fillStyle = "#e0b46a";
          else ctx.fillStyle = "#0e1422";
          ctx.fillRect(px + x * tile, py + y * tile, tile - 0.4, tile - 0.4);
        }
      }

      ctx.fillStyle = "#6de0ff";
      ctx.beginPath();
      ctx.arc(px + state.player.x * tile, py + state.player.y * tile, 3.2, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "#6de0ff";
      ctx.beginPath();
      ctx.moveTo(px + state.player.x * tile, py + state.player.y * tile);
      ctx.lineTo(
        px + (state.player.x + Math.cos(state.player.a) * 2.0) * tile,
        py + (state.player.y + Math.sin(state.player.a) * 2.0) * tile
      );
      ctx.stroke();
    }

    function update() {
      if (!state.inBattle && !state.over) {
        const turn = 0.05;
        const move = 0.065;
        if (keys.has("ArrowLeft") || keys.has("KeyA")) state.player.a -= turn;
        if (keys.has("ArrowRight") || keys.has("KeyD")) state.player.a += turn;

        if (keys.has("ArrowUp") || keys.has("KeyW")) {
          const v = forwardVec();
          tryMove(v.x * move, v.y * move);
        }
        if (keys.has("ArrowDown") || keys.has("KeyS")) {
          const v = forwardVec();
          tryMove(-v.x * move, -v.y * move);
        }
        if (keys.has("KeyQ")) {
          const v = rightVec();
          tryMove(-v.x * move, -v.y * move);
        }
        if (keys.has("KeyE")) {
          const v = rightVec();
          tryMove(v.x * move, v.y * move);
        }
      }

      drawWorld();
      drawMiniMap();
      requestAnimationFrame(update);
    }

    function oneShot(act) {
      const move = 0.28;
      const turn = Math.PI / 2;
      if (act === "turnLeft") state.player.a -= turn;
      if (act === "turnRight") state.player.a += turn;
      if (act === "forward") {
        const v = forwardVec();
        tryMove(v.x * move, v.y * move);
      }
      if (act === "backward") {
        const v = forwardVec();
        tryMove(-v.x * move, -v.y * move);
      }
      if (act === "strafeLeft") {
        const v = rightVec();
        tryMove(-v.x * move, -v.y * move);
      }
      if (act === "strafeRight") {
        const v = rightVec();
        tryMove(v.x * move, v.y * move);
      }
      if (act === "use") useTile();
    }

    document.getElementById("btn-attack").addEventListener("click", attack);
    document.getElementById("btn-guard").addEventListener("click", guard);
    document.getElementById("btn-flee").addEventListener("click", flee);
    document.getElementById("btn-restart").addEventListener("click", () => {
      endOverlay.classList.remove("active");
      state.floor = 1;
      state.hp = 30;
      state.atk = 6;
      state.steps = 0;
      state.wins = 0;
      state.over = false;
      state.inBattle = false;
      buildFloor();
      setStats();
    });

    document.querySelectorAll("[data-act]").forEach((el) => {
      el.addEventListener("click", () => oneShot(el.getAttribute("data-act")));
    });

    document.addEventListener("keydown", (e) => {
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].includes(e.code)) e.preventDefault();
      if (e.code === "Enter") useTile();
      keys.add(e.code);
    }, { passive: false });
    document.addEventListener("keyup", (e) => keys.delete(e.code));
    window.addEventListener("blur", () => keys.clear());

    buildFloor();
    setStats();
    update();
  </script>
</body>
</html>
