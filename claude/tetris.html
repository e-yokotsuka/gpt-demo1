<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta name="ai.author" content="Claude">
	<meta name="ai.note" content="This file was generated by Claude.">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Tetris (PixiJS) - Claude版</title>
	<style>
		body { margin: 0; overflow: hidden; background: #111; }
		canvas { display: block; }
	</style>
</head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.3/pixi.min.js"></script>
	<script>
		// ClaudeによるテトリスPixiJS版
		// ネクスト表示、ゴーストピース、エフェクト付き
		const COLS = 10, ROWS = 20, CELL = 30;
		const BOARD_W = COLS * CELL;
		const BOARD_H = ROWS * CELL;
		const SIDEBAR = 180;

		const app = new PIXI.Application({
			width: BOARD_W + SIDEBAR,
			height: BOARD_H,
			backgroundColor: 0x111122
		});
		document.body.appendChild(app.view);

		const arena = Array.from({ length: ROWS }, () => new Array(COLS).fill(0));
		const colors = [0x000000, 0x00f0f0, 0x0000f0, 0xf0a000, 0xf0f000, 0x00f000, 0xa000f0, 0xf00000];

		const shapes = {
			I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
			J: [[2,0,0],[2,2,2],[0,0,0]],
			L: [[0,0,3],[3,3,3],[0,0,0]],
			O: [[4,4],[4,4]],
			S: [[0,5,5],[5,5,0],[0,0,0]],
			T: [[0,6,0],[6,6,6],[0,0,0]],
			Z: [[7,7,0],[0,7,7],[0,0,0]]
		};

		const boardGfx = new PIXI.Graphics();
		const pieceGfx = new PIXI.Graphics();
		const ghostGfx = new PIXI.Graphics();
		const nextGfx = new PIXI.Graphics();
		app.stage.addChild(boardGfx, ghostGfx, pieceGfx, nextGfx);

		// サイドバーテキスト
		const style = { fontFamily: 'monospace', fontSize: 16, fill: '#ffffff' };
		const scoreText = new PIXI.Text('Score: 0', style);
		scoreText.position.set(BOARD_W + 15, 20);
		const linesText = new PIXI.Text('Lines: 0', style);
		linesText.position.set(BOARD_W + 15, 50);
		const levelText = new PIXI.Text('Level: 1', style);
		levelText.position.set(BOARD_W + 15, 80);
		const nextLabel = new PIXI.Text('Next:', style);
		nextLabel.position.set(BOARD_W + 15, 120);
		const controlsText = new PIXI.Text('←→:移動\n↓:落下\nQ W:回転', { ...style, fontSize: 13, fill: '#888888' });
		controlsText.position.set(BOARD_W + 15, 250);
		app.stage.addChild(scoreText, linesText, levelText, nextLabel, controlsText);

		const player = { pos: { x: 0, y: 0 }, matrix: null };
		let score = 0, lines = 0, level = 1;
		let dropCounter = 0, dropInterval = 500, lastTime = Date.now();
		let nextPiece = null;

		function clone(m) { return m.map(r => [...r]); }

		function collide(a, p) {
			for (let y = 0; y < p.matrix.length; y++)
				for (let x = 0; x < p.matrix[y].length; x++)
					if (p.matrix[y][x] && (!a[y + p.pos.y] || a[y + p.pos.y][x + p.pos.x] !== 0))
						return true;
			return false;
		}

		function merge(a, p) {
			p.matrix.forEach((row, y) => row.forEach((v, x) => {
				if (v) a[y + p.pos.y][x + p.pos.x] = v;
			}));
		}

		function rotate(m, dir) {
			for (let y = 0; y < m.length; y++)
				for (let x = 0; x < y; x++)
					[m[x][y], m[y][x]] = [m[y][x], m[x][y]];
			if (dir > 0) m.forEach(r => r.reverse());
			else m.reverse();
		}

		function sweep() {
			let cleared = 0;
			outer: for (let y = ROWS - 1; y >= 0; y--) {
				for (let x = 0; x < COLS; x++) if (arena[y][x] === 0) continue outer;
				arena.splice(y, 1);
				arena.unshift(new Array(COLS).fill(0));
				y++;
				cleared++;
			}
			if (cleared) {
				score += [0, 100, 300, 500, 800][cleared] * level;
				lines += cleared;
				level = Math.floor(lines / 10) + 1;
				dropInterval = Math.max(80, 500 - (level - 1) * 40);
				scoreText.text = `Score: ${score}`;
				linesText.text = `Lines: ${lines}`;
				levelText.text = `Level: ${level}`;
			}
		}

		function randomPiece() {
			const keys = 'IJLOSTZ';
			return clone(shapes[keys[Math.floor(Math.random() * keys.length)]]);
		}

		function resetPlayer() {
			player.matrix = nextPiece || randomPiece();
			nextPiece = randomPiece();
			player.pos.y = 0;
			player.pos.x = Math.floor((COLS - player.matrix[0].length) / 2);
			if (collide(arena, player)) {
				arena.forEach(r => r.fill(0));
				score = 0; lines = 0; level = 1;
				dropInterval = 500;
				scoreText.text = 'Score: 0';
				linesText.text = 'Lines: 0';
				levelText.text = 'Level: 1';
			}
			drawNext();
		}

		function drop() {
			player.pos.y++;
			if (collide(arena, player)) {
				player.pos.y--;
				merge(arena, player);
				sweep();
				resetPlayer();
			}
			dropCounter = 0;
		}

		function moveP(dir) {
			player.pos.x += dir;
			if (collide(arena, player)) player.pos.x -= dir;
		}

		function rotateP(dir) {
			const px = player.pos.x;
			let off = 1;
			rotate(player.matrix, dir);
			while (collide(arena, player)) {
				player.pos.x += off;
				off = -(off + (off > 0 ? 1 : -1));
				if (off > player.matrix[0].length) { rotate(player.matrix, -dir); player.pos.x = px; return; }
			}
		}

		function getGhostY() {
			let gy = player.pos.y;
			while (!collide(arena, { matrix: player.matrix, pos: { x: player.pos.x, y: gy + 1 } })) gy++;
			return gy;
		}

		function drawCell(gfx, x, y, color, alpha = 1) {
			gfx.beginFill(color, alpha);
			gfx.drawRect(x * CELL + 1, y * CELL + 1, CELL - 2, CELL - 2);
			gfx.endFill();
		}

		function drawBoard() {
			boardGfx.clear();
			// グリッド
			boardGfx.lineStyle(1, 0x222233);
			for (let x = 0; x <= COLS; x++) { boardGfx.moveTo(x * CELL, 0); boardGfx.lineTo(x * CELL, BOARD_H); }
			for (let y = 0; y <= ROWS; y++) { boardGfx.moveTo(0, y * CELL); boardGfx.lineTo(BOARD_W, y * CELL); }
			// 固定ブロック
			for (let y = 0; y < ROWS; y++)
				for (let x = 0; x < COLS; x++)
					if (arena[y][x]) drawCell(boardGfx, x, y, colors[arena[y][x]]);
		}

		function drawPiece() {
			pieceGfx.clear();
			player.matrix.forEach((row, y) => row.forEach((v, x) => {
				if (v) drawCell(pieceGfx, x + player.pos.x, y + player.pos.y, colors[v]);
			}));
		}

		function drawGhost() {
			ghostGfx.clear();
			const gy = getGhostY();
			player.matrix.forEach((row, y) => row.forEach((v, x) => {
				if (v) drawCell(ghostGfx, x + player.pos.x, y + gy, colors[v], 0.2);
			}));
		}

		function drawNext() {
			nextGfx.clear();
			if (!nextPiece) return;
			const ox = BOARD_W + 20;
			const oy = 150;
			nextPiece.forEach((row, y) => row.forEach((v, x) => {
				if (v) {
					nextGfx.beginFill(colors[v]);
					nextGfx.drawRect(ox + x * 20, oy + y * 20, 18, 18);
					nextGfx.endFill();
				}
			}));
		}

		document.addEventListener('keydown', e => {
			if (e.key === 'ArrowLeft') moveP(-1);
			else if (e.key === 'ArrowRight') moveP(1);
			else if (e.key === 'ArrowDown') drop();
			else if (e.key === 'q' || e.key === 'Q') rotateP(-1);
			else if (e.key === 'w' || e.key === 'W') rotateP(1);
		});

		nextPiece = randomPiece();
		resetPlayer();

		app.ticker.add(() => {
			const now = Date.now();
			dropCounter += now - lastTime;
			lastTime = now;
			if (dropCounter > dropInterval) drop();

			drawBoard();
			drawGhost();
			drawPiece();
		});
	</script>
</body>
</html>
