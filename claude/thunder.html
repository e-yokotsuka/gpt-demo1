<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta name="ai.author" content="Claude">
	<meta name="ai.note" content="This file was generated by Claude.">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Electrifying Thunderstorm - Claude版</title>
	<style>
		body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; }
		canvas { display: block; }
	</style>
</head>
<body>
	<canvas id="canvas"></canvas>
	<script>
		// Claudeによる雷デモ
		// 分岐する稲妻、フラッシュ効果、雨を追加
		const canvas = document.getElementById('canvas');
		const ctx = canvas.getContext('2d');
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;

		let flashAlpha = 0;

		class Lightning {
			constructor(x, y, angle, depth) {
				this.segments = [];
				this.life = 1.0;
				this.decay = Math.random() * 0.02 + 0.01;
				this.width = Math.max(1, 4 - depth);
				this.children = [];
				this.generatePath(x, y, angle, depth);
			}

			generatePath(startX, startY, angle, depth) {
				let x = startX;
				let y = startY;
				const segCount = Math.floor(Math.random() * 15 + 10);

				for (let i = 0; i < segCount; i++) {
					const len = Math.random() * 20 + 10;
					angle += (Math.random() - 0.5) * 0.6;
					const nx = x + Math.cos(angle) * len;
					const ny = y + Math.sin(angle) * len;
					this.segments.push({ x1: x, y1: y, x2: nx, y2: ny });
					x = nx;
					y = ny;

					// 分岐
					if (depth < 3 && Math.random() < 0.15) {
						const branchAngle = angle + (Math.random() - 0.5) * 1.2;
						this.children.push(new Lightning(x, y, branchAngle, depth + 1));
					}
				}
			}

			update() {
				this.life -= this.decay;
				for (const child of this.children) {
					child.life = this.life;
				}
			}

			draw() {
				if (this.life <= 0) return;
				ctx.strokeStyle = `rgba(200, 220, 255, ${this.life})`;
				ctx.lineWidth = this.width * this.life;
				ctx.shadowColor = '#88aaff';
				ctx.shadowBlur = 10;

				ctx.beginPath();
				for (const seg of this.segments) {
					ctx.moveTo(seg.x1, seg.y1);
					ctx.lineTo(seg.x2, seg.y2);
				}
				ctx.stroke();
				ctx.shadowBlur = 0;

				for (const child of this.children) {
					child.draw();
				}
			}

			isDead() {
				return this.life <= 0;
			}
		}

		// 雨粒
		const raindrops = Array.from({ length: 200 }, () => ({
			x: Math.random() * canvas.width,
			y: Math.random() * canvas.height,
			speed: Math.random() * 8 + 4,
			length: Math.random() * 15 + 5
		}));

		const lightnings = [];

		function animate() {
			// 暗い空
			ctx.fillStyle = `rgba(5, 5, 15, ${flashAlpha > 0 ? 0.3 : 0.85})`;
			ctx.fillRect(0, 0, canvas.width, canvas.height);

			// フラッシュ効果
			if (flashAlpha > 0) {
				ctx.fillStyle = `rgba(150, 170, 220, ${flashAlpha})`;
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				flashAlpha -= 0.05;
			}

			// 雨
			ctx.strokeStyle = 'rgba(100, 130, 180, 0.3)';
			ctx.lineWidth = 1;
			for (const drop of raindrops) {
				ctx.beginPath();
				ctx.moveTo(drop.x, drop.y);
				ctx.lineTo(drop.x - 1, drop.y + drop.length);
				ctx.stroke();
				drop.y += drop.speed;
				drop.x -= 0.5;
				if (drop.y > canvas.height) {
					drop.y = -drop.length;
					drop.x = Math.random() * canvas.width;
				}
			}

			// 新しい稲妻を生成
			if (Math.random() < 0.02) {
				const x = Math.random() * canvas.width;
				lightnings.push(new Lightning(x, 0, Math.PI / 2, 0));
				flashAlpha = 0.3;
			}

			// 稲妻の更新と描画
			for (let i = lightnings.length - 1; i >= 0; i--) {
				lightnings[i].update();
				lightnings[i].draw();
				if (lightnings[i].isDead()) {
					lightnings.splice(i, 1);
				}
			}

			requestAnimationFrame(animate);
		}

		animate();

		window.addEventListener('resize', () => {
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
		});
	</script>
</body>
</html>
