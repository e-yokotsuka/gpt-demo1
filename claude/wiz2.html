<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta name="ai.author" content="Claude">
	<meta name="ai.note" content="This file was generated by Claude.">
	<title>Wizardry 3D Dungeon - Claude版</title>
	<style>
		body { margin: 0; padding: 0; overflow: hidden; }
	</style>
</head>
<body>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
	<script>
		// Claudeによるウィザードリィ3Dダンジョン
		// 一人称視点、ライティング付き
		const scene = new THREE.Scene();
		scene.background = new THREE.Color(0x111122);
		scene.fog = new THREE.Fog(0x111122, 0, 12);

		const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
		const renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setSize(window.innerWidth, window.innerHeight);
		document.body.appendChild(renderer.domElement);

		// ライティング
		const torch = new THREE.PointLight(0xffaa44, 1.5, 8);
		camera.add(torch);
		torch.position.set(0, 0.5, 0);
		scene.add(camera);
		scene.add(new THREE.AmbientLight(0x222244, 0.3));

		const mapData = [
			[1,1,1,1,1,1,1,1,1,1],
			[1,0,0,0,1,0,0,0,0,1],
			[1,0,1,0,1,0,1,1,0,1],
			[1,0,1,0,0,0,0,1,0,1],
			[1,0,1,1,1,1,0,1,0,1],
			[1,0,0,0,0,1,0,0,0,1],
			[1,1,1,1,0,1,0,1,1,1],
			[1,0,0,0,0,0,0,0,0,1],
			[1,0,1,1,1,1,1,1,0,1],
			[1,1,1,1,1,1,1,1,1,1],
		];

		const wallMat = new THREE.MeshPhongMaterial({ color: 0x556688 });
		const floorMat = new THREE.MeshPhongMaterial({ color: 0x334455 });
		const ceilMat = new THREE.MeshPhongMaterial({ color: 0x223344 });

		// ダンジョン構築
		for (let y = 0; y < mapData.length; y++) {
			for (let x = 0; x < mapData[y].length; x++) {
				if (mapData[y][x] === 1) {
					const wall = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), wallMat);
					wall.position.set(x, 0.5, y);
					scene.add(wall);
				}
				// 床
				const floor = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), floorMat);
				floor.rotation.x = -Math.PI / 2;
				floor.position.set(x, 0, y);
				scene.add(floor);
				// 天井
				const ceil = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), ceilMat);
				ceil.rotation.x = Math.PI / 2;
				ceil.position.set(x, 1, y);
				scene.add(ceil);
			}
		}

		// プレイヤー位置と向き
		let px = 1.5, py = 1.5;
		let dir = 0; // 0=東, 1=南, 2=西, 3=北
		const dirs = [
			{ dx: 1, dz: 0 },
			{ dx: 0, dz: 1 },
			{ dx: -1, dz: 0 },
			{ dx: 0, dz: -1 }
		];

		function updateCamera() {
			camera.position.set(px, 0.5, py);
			const d = dirs[dir];
			camera.lookAt(px + d.dx, 0.5, py + d.dz);
		}
		updateCamera();

		// HUD
		const hud = document.createElement('div');
		hud.style.cssText = 'position:fixed;top:10px;left:10px;color:#aab;font:14px sans-serif;background:rgba(0,0,0,0.5);padding:8px;border-radius:4px;';
		hud.textContent = '↑:前進 ↓:後退 ←→:回転';
		document.body.appendChild(hud);

		// 移動
		let cooldown = 0;
		const keys = {};
		document.addEventListener('keydown', e => { keys[e.key] = true; e.preventDefault(); });
		document.addEventListener('keyup', e => { keys[e.key] = false; });

		function canMove(nx, ny) {
			const mx = Math.floor(nx);
			const my = Math.floor(ny);
			return mx >= 0 && mx < mapData[0].length && my >= 0 && my < mapData.length && mapData[my][mx] === 0;
		}

		function animate() {
			requestAnimationFrame(animate);

			if (cooldown > 0) { cooldown--; }
			else {
				if (keys['ArrowLeft']) { dir = (dir + 3) % 4; cooldown = 10; }
				else if (keys['ArrowRight']) { dir = (dir + 1) % 4; cooldown = 10; }
				else if (keys['ArrowUp']) {
					const d = dirs[dir];
					const nx = px + d.dx;
					const ny = py + d.dz;
					if (canMove(nx, ny)) { px = nx; py = ny; }
					cooldown = 10;
				}
				else if (keys['ArrowDown']) {
					const d = dirs[dir];
					const nx = px - d.dx;
					const ny = py - d.dz;
					if (canMove(nx, ny)) { px = nx; py = ny; }
					cooldown = 10;
				}
				updateCamera();
			}

			// たいまつの揺れ
			torch.intensity = 1.5 + Math.sin(Date.now() * 0.01) * 0.2;

			renderer.render(scene, camera);
		}

		animate();

		window.addEventListener('resize', () => {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize(window.innerWidth, window.innerHeight);
		});
	</script>
</body>
</html>
