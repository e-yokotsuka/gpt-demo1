<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta name="ai.author" content="Claude">
	<meta name="ai.note" content="This file was generated by Claude.">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Mandelbrot OpenLayers - Claude版</title>
	<script src="https://cdn.jsdelivr.net/npm/ol@v7.3.0/dist/ol.js"></script>
	<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.3.0/ol.css">
	<style>
		body { margin: 0; }
		#map { width: 100%; height: 100vh; }
	</style>
</head>
<body>
	<div id="map"></div>
	<script>
		// Claudeによるマンデルブロ集合 (OpenLayers版)
		// カラフルなカラーパレット
		function hslToRgb(h, s, l) {
			h /= 360; s /= 100; l /= 100;
			let r, g, b;
			if (s === 0) { r = g = b = l; }
			else {
				const hue2rgb = (p, q, t) => {
					if (t < 0) t += 1;
					if (t > 1) t -= 1;
					if (t < 1/6) return p + (q - p) * 6 * t;
					if (t < 1/2) return q;
					if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
					return p;
				};
				const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
				const p = 2 * l - q;
				r = hue2rgb(p, q, h + 1/3);
				g = hue2rgb(p, q, h);
				b = hue2rgb(p, q, h - 1/3);
			}
			return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
		}

		const mandelbrotLayer = new ol.layer.Image({
			source: new ol.source.ImageCanvas({
				canvasFunction: function(extent, resolution, pixelRatio, size, projection) {
					const canvas = document.createElement('canvas');
					canvas.width = size[0];
					canvas.height = size[1];
					const ctx = canvas.getContext('2d');
					const imageData = ctx.createImageData(size[0], size[1]);
					const maxIter = 200;

					for (let px = 0; px < size[0]; px++) {
						for (let py = 0; py < size[1]; py++) {
							const coord = ol.proj.toLonLat(
								[extent[0] + px * resolution, extent[3] - py * resolution],
								projection
							);
							const cx = coord[0] / 180;
							const cy = coord[1] / 90;

							let x = 0, y = 0, iter = 0;
							while (x * x + y * y <= 4 && iter < maxIter) {
								const xNew = x * x - y * y + cx;
								y = 2 * x * y + cy;
								x = xNew;
								iter++;
							}

							const idx = (py * size[0] + px) * 4;
							if (iter === maxIter) {
								imageData.data[idx] = 0;
								imageData.data[idx + 1] = 0;
								imageData.data[idx + 2] = 0;
							} else {
								const hue = (iter * 6) % 360;
								const [r, g, b] = hslToRgb(hue, 85, 55);
								imageData.data[idx] = r;
								imageData.data[idx + 1] = g;
								imageData.data[idx + 2] = b;
							}
							imageData.data[idx + 3] = 255;
						}
					}

					ctx.putImageData(imageData, 0, 0);
					return canvas;
				},
				projection: 'EPSG:4326'
			})
		});

		const map = new ol.Map({
			target: 'map',
			layers: [mandelbrotLayer],
			view: new ol.View({
				center: ol.proj.fromLonLat([0, 0], 'EPSG:3857'),
				zoom: 1,
				maxZoom: 22
			})
		});
	</script>
</body>
</html>
