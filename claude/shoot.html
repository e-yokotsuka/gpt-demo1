<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta name="ai.author" content="Claude">
	<meta name="ai.note" content="This file was generated by Claude Opus 4.6.">
	<title>Shooting Game - Claude Opus 4.6</title>
	<style>
		:root {
			--bg: #06081a;
			--panel: rgba(8, 14, 32, 0.88);
			--text: #e0e8ff;
			--muted: #7b8db8;
			--accent: #53ffa6;
			--accent2: #ff6eb4;
			--danger: #ff4466;
			--gold: #ffd666;
		}
		* { box-sizing: border-box; margin: 0; padding: 0; }
		body {
			background:
				radial-gradient(circle at 15% 10%, rgba(83, 255, 166, 0.12), transparent 40%),
				radial-gradient(circle at 85% 8%, rgba(255, 110, 180, 0.14), transparent 40%),
				linear-gradient(150deg, #060818, #0a1030);
			color: var(--text);
			font-family: "Segoe UI", "Hiragino Kaku Gothic ProN", Meiryo, sans-serif;
			overflow: hidden;
			height: 100vh;
		}
		.app {
			max-width: 1200px;
			margin: 0 auto;
			padding: 10px;
			height: 100vh;
			display: grid;
			grid-template-rows: auto auto 1fr auto;
			gap: 8px;
		}
		.top {
			display: flex;
			justify-content: space-between;
			align-items: center;
			background: var(--panel);
			border: 1px solid rgba(255,255,255,0.12);
			border-radius: 10px;
			padding: 6px 12px;
		}
		.title {
			font-size: clamp(16px, 2.8vw, 24px);
			font-weight: 800;
			background: linear-gradient(90deg, var(--accent), var(--accent2));
			-webkit-background-clip: text;
			-webkit-text-fill-color: transparent;
		}
		.controls { display: flex; gap: 6px; }
		.btn {
			border: 1px solid rgba(255,255,255,0.2);
			color: var(--text);
			background: rgba(255,255,255,0.07);
			border-radius: 999px;
			padding: 5px 12px;
			cursor: pointer;
			font-weight: 700;
			font-size: 13px;
		}
		.btn.primary {
			background: linear-gradient(120deg, var(--accent), var(--accent2));
			color: #081225;
			border-color: transparent;
		}
		.hud {
			display: grid;
			grid-template-columns: repeat(5, 1fr);
			gap: 6px;
		}
		.card {
			background: var(--panel);
			border: 1px solid rgba(255,255,255,0.1);
			border-radius: 8px;
			padding: 5px 8px;
			text-align: center;
		}
		.card .label { font-size: 10px; color: var(--muted); text-transform: uppercase; }
		.card .val { font-size: 20px; font-weight: 800; line-height: 1.2; }
		.card .val.accent { color: var(--accent); }
		.card .val.danger { color: var(--danger); }
		.card .val.gold { color: var(--gold); }
		.stage {
			position: relative;
			background: #02040c;
			border: 1px solid rgba(255,255,255,0.12);
			border-radius: 12px;
			overflow: hidden;
			min-height: 260px;
		}
		canvas { width: 100%; height: 100%; display: block; }
		.overlay {
			position: absolute; inset: 0;
			display: none; align-items: center; justify-content: center;
			background: rgba(2, 4, 14, 0.75);
			backdrop-filter: blur(3px);
			text-align: center;
		}
		.overlay.show { display: flex; }
		.box {
			max-width: 480px;
			background: rgba(8, 14, 32, 0.96);
			border: 1px solid rgba(255,255,255,0.14);
			border-radius: 12px;
			padding: 20px;
		}
		.box h2 { font-size: 32px; margin-bottom: 10px; }
		.box p { color: var(--muted); margin: 6px 0; line-height: 1.5; font-size: 14px; }
		.box .btn { margin-top: 12px; padding: 8px 28px; font-size: 16px; }
		.touch {
			display: none;
			grid-template-columns: repeat(5, 1fr);
			gap: 6px;
		}
		.touch button {
			border-radius: 8px;
			border: 1px solid rgba(255,255,255,0.18);
			background: rgba(255,255,255,0.07);
			color: var(--text);
			padding: 10px 0;
			font-weight: 700;
			font-size: 15px;
		}
		@media (max-width: 760px) {
			.hud { grid-template-columns: repeat(3, 1fr); }
			.touch { display: grid; }
			.card .val { font-size: 16px; }
		}
	</style>
</head>
<body>
	<div class="app">
		<div class="top">
			<div class="title">Shooting Game // Claude Opus 4.6</div>
			<div class="controls">
				<button class="btn" id="pauseBtn">Pause</button>
				<button class="btn" id="restartBtn">Restart</button>
			</div>
		</div>
		<div class="hud">
			<div class="card"><div class="label">Score</div><div class="val accent" id="hScore">0</div></div>
			<div class="card"><div class="label">Lives</div><div class="val danger" id="hLives">3</div></div>
			<div class="card"><div class="label">Bomb</div><div class="val gold" id="hBombs">3</div></div>
			<div class="card"><div class="label">Power</div><div class="val" id="hPower">1</div></div>
			<div class="card"><div class="label">Multi</div><div class="val" id="hMulti">x1</div></div>
		</div>
		<div class="stage" id="stage">
			<canvas id="game" width="1280" height="720"></canvas>
			<div class="overlay show" id="startOverlay">
				<div class="box">
					<h2>Launch</h2>
					<p>Move: Arrow / WASD &nbsp; Shoot: Space / J &nbsp; Bomb: K</p>
					<p>Pause: P &nbsp; Restart: R</p>
					<p>Bomb clears all bullets and enemies. Collect cyan chips for power-up!</p>
					<button class="btn primary" id="startBtn">Start</button>
				</div>
			</div>
			<div class="overlay" id="overOverlay">
				<div class="box">
					<h2>Game Over</h2>
					<p id="finalScore"></p>
					<button class="btn primary" id="retryBtn">Retry</button>
				</div>
			</div>
		</div>
		<div class="touch" id="touch">
			<button data-k="left">&#9664;</button>
			<button data-k="right">&#9654;</button>
			<button data-k="up">&#9650;</button>
			<button data-k="shoot">FIRE</button>
			<button data-k="bomb">BOMB</button>
		</div>
	</div>

<script>
// ===== セットアップ =====
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const stageEl = document.getElementById("stage");

const W = 1280;
const H = 720;
const GROUND = H - 44;

// ===== ゲーム状態 =====
const state = {
	started: false,
	paused: false,
	over: false,
	score: 0,
	lives: 3,
	bombs: 3,
	multi: 1,
	t: 0,
	spawnTimer: 0,
	fireCd: 0,
	hitFlash: 0,
	waveLevel: 0,
	bossActive: false,
};

const key = { up: false, down: false, left: false, right: false, shoot: false };

// ===== エンティティ =====
const player = { x: 100, y: H * 0.45, w: 48, h: 26, speed: 440, inv: 0, power: 1 };
const bullets = [];
const enemies = [];
const enemyBullets = [];
const chips = [];
const particles = [];

// ===== 星背景 =====
const stars = Array.from({ length: 180 }, () => ({
	x: Math.random() * W,
	y: Math.random() * (GROUND - 10),
	r: Math.random() * 2 + 0.3,
	s: Math.random() * 1.5 + 0.2,
	a: Math.random() * 0.6 + 0.3,
}));

// ===== 星雲（背景の深み） =====
const nebulae = Array.from({ length: 5 }, () => ({
	x: Math.random() * W,
	y: Math.random() * GROUND * 0.6,
	r: 80 + Math.random() * 120,
	hue: Math.random() * 360,
	a: 0.03 + Math.random() * 0.04,
}));

// ===== HUD更新 =====
function updateHUD() {
	document.getElementById("hScore").textContent = Math.floor(state.score);
	document.getElementById("hLives").textContent = state.lives;
	document.getElementById("hBombs").textContent = state.bombs;
	document.getElementById("hPower").textContent = "\u2605".repeat(player.power);
	document.getElementById("hMulti").textContent = "x" + state.multi;
}

// ===== リサイズ =====
function resize() {
	const r = stageEl.getBoundingClientRect();
	const sw = Math.max(320, r.width);
	const sh = Math.max(200, r.height);
	let dw = sw;
	let dh = (dw * H) / W;
	if (dh > sh) { dh = sh; dw = (dh * W) / H; }
	canvas.style.width = Math.floor(dw) + "px";
	canvas.style.height = Math.floor(dh) + "px";
}

// ===== リセット =====
function resetGame() {
	state.started = false;
	state.paused = false;
	state.over = false;
	state.score = 0;
	state.lives = 3;
	state.bombs = 3;
	state.multi = 1;
	state.t = 0;
	state.spawnTimer = 0;
	state.fireCd = 0;
	state.hitFlash = 0;
	state.waveLevel = 0;
	state.bossActive = false;
	player.x = 100;
	player.y = H * 0.45;
	player.inv = 0;
	player.power = 1;
	bullets.length = 0;
	enemies.length = 0;
	enemyBullets.length = 0;
	chips.length = 0;
	particles.length = 0;
	document.getElementById("startOverlay").classList.add("show");
	document.getElementById("overOverlay").classList.remove("show");
	updateHUD();
}

// ===== 敵生成 =====
function spawnEnemy() {
	const wl = state.waveLevel;
	const type = Math.floor(Math.random() * 4);
	const e = {
		x: W + 40,
		y: 30 + Math.random() * (GROUND - 100),
		w: [32, 36, 28, 44][type],
		h: [28, 32, 24, 38][type],
		hp: [1, 2, 1, 4][type] + Math.floor(wl * 0.3),
		maxHp: [1, 2, 1, 4][type] + Math.floor(wl * 0.3),
		t: 0,
		type: type,
		speed: [200, 160, 280, 120][type] + wl * 8,
		fireTimer: 0.8 + Math.random() * 1.5,
		color: ["#ff5068", "#4d8aff", "#d96aff", "#ffaa33"][type],
		points: [100, 160, 200, 400][type],
	};
	enemies.push(e);
}

// ===== パーティクル爆発 =====
function burst(x, y, color, count) {
	for (let i = 0; i < count; i++) {
		const a = Math.random() * Math.PI * 2;
		const s = Math.random() * 260 + 50;
		particles.push({
			x: x, y: y,
			vx: Math.cos(a) * s,
			vy: Math.sin(a) * s,
			life: 0.4 + Math.random() * 0.6,
			color: color,
			size: 2 + Math.random() * 3,
		});
	}
}

// ===== プレイヤー発射 =====
function firePlayer() {
	const cx = player.x + player.w;
	const cy = player.y + player.h * 0.5;
	bullets.push({ x: cx, y: cy, vx: 820, vy: 0 });
	if (player.power >= 2) {
		bullets.push({ x: cx - 4, y: cy - 12, vx: 800, vy: -60 });
		bullets.push({ x: cx - 4, y: cy + 12, vx: 800, vy: 60 });
	}
	if (player.power >= 3) {
		bullets.push({ x: cx - 2, y: cy, vx: 900, vy: 0 });
		bullets.push({ x: cx - 6, y: cy - 20, vx: 760, vy: -120 });
		bullets.push({ x: cx - 6, y: cy + 20, vx: 760, vy: 120 });
	}
}

// ===== ボム =====
function useBomb() {
	if (state.bombs <= 0) return;
	state.bombs--;
	// 画面全体フラッシュ
	burst(player.x + player.w * 0.5, player.y + player.h * 0.5, "rgba(83,255,166,0.9)", 80);
	// 全敵と敵弾を消去
	for (let i = enemies.length - 1; i >= 0; i--) {
		state.score += enemies[i].points * state.multi;
		burst(enemies[i].x + enemies[i].w * 0.5, enemies[i].y + enemies[i].h * 0.5, enemies[i].color, 10);
		if (Math.random() < 0.25) chips.push({ x: enemies[i].x, y: enemies[i].y, w: 14, h: 14 });
		enemies.splice(i, 1);
	}
	enemyBullets.length = 0;
	state.multi = Math.min(12, state.multi + 1);
	updateHUD();
}

// ===== 被弾 =====
function hitPlayer() {
	if (player.inv > 0) return;
	state.lives--;
	player.inv = 1.5;
	state.hitFlash = 0.5;
	state.multi = 1;
	burst(player.x + player.w * 0.5, player.y + player.h * 0.5, "rgba(255,68,102,0.95)", 45);
	if (state.lives <= 0) {
		state.over = true;
		document.getElementById("finalScore").textContent = "Score: " + Math.floor(state.score);
		document.getElementById("overOverlay").classList.add("show");
	}
	updateHUD();
}

// ===== AABB衝突判定 =====
function intersects(a, b) {
	return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;
}

// ===== 更新処理 =====
function update(dt) {
	state.t += dt;
	state.spawnTimer += dt;
	state.fireCd = Math.max(0, state.fireCd - dt);
	player.inv = Math.max(0, player.inv - dt);
	state.hitFlash = Math.max(0, state.hitFlash - dt);

	// ウェーブレベル上昇
	state.waveLevel = Math.floor(state.t / 15);

	// プレイヤー移動
	const mv = player.speed * dt;
	if (key.up) player.y -= mv;
	if (key.down) player.y += mv;
	if (key.left) player.x -= mv;
	if (key.right) player.x += mv;
	player.x = Math.max(8, Math.min(W * 0.6, player.x));
	player.y = Math.max(8, Math.min(GROUND - player.h - 4, player.y));

	// 射撃
	if (key.shoot && state.fireCd <= 0) {
		firePlayer();
		state.fireCd = Math.max(0.05, 0.15 - player.power * 0.025);
	}

	// 敵スポーン
	const spawnInterval = Math.max(0.3, 1.1 - state.t * 0.015);
	if (state.spawnTimer > spawnInterval) {
		state.spawnTimer = 0;
		spawnEnemy();
	}

	// 自弾の更新
	for (const b of bullets) {
		b.x += b.vx * dt;
		b.y += b.vy * dt;
	}
	for (let i = bullets.length - 1; i >= 0; i--) {
		const b = bullets[i];
		if (b.x > W + 20 || b.y < -20 || b.y > GROUND + 20) bullets.splice(i, 1);
	}

	// 敵の更新
	for (const e of enemies) {
		e.t += dt;
		e.x -= e.speed * dt;
		// 移動パターン
		if (e.type === 0) e.y += Math.sin(e.t * 6) * 2.0;
		if (e.type === 1) e.y += Math.cos(e.t * 4) * 1.5;
		if (e.type === 2) e.y += Math.sin(e.t * 10) * 2.8;
		if (e.type === 3) {
			e.y += Math.sin(e.t * 3) * 1.0;
			// ボス級は画面端で止まる
			if (e.x < W * 0.7) e.x = W * 0.7;
		}
		// 敵弾発射
		e.fireTimer -= dt;
		if (e.fireTimer <= 0) {
			e.fireTimer = 0.8 + Math.random() * 1.6 - state.waveLevel * 0.05;
			const dx = player.x - e.x;
			const dy = player.y - e.y;
			const dist = Math.sqrt(dx * dx + dy * dy) || 1;
			const spd = 260 + Math.random() * 100 + state.waveLevel * 10;
			enemyBullets.push({
				x: e.x, y: e.y + e.h * 0.5,
				vx: (dx / dist) * spd,
				vy: (dy / dist) * spd,
			});
			if (e.type === 3) {
				// ボス級は3方向弾
				const angle = Math.atan2(dy, dx);
				for (let off = -1; off <= 1; off += 2) {
					const a2 = angle + off * 0.2;
					enemyBullets.push({
						x: e.x, y: e.y + e.h * 0.5,
						vx: Math.cos(a2) * spd * 0.9,
						vy: Math.sin(a2) * spd * 0.9,
					});
				}
			}
		}
	}
	for (let i = enemies.length - 1; i >= 0; i--) {
		if (enemies[i].x + enemies[i].w < -60) enemies.splice(i, 1);
	}

	// 敵弾の更新
	for (const eb of enemyBullets) {
		eb.x += eb.vx * dt;
		eb.y += eb.vy * dt;
	}
	for (let i = enemyBullets.length - 1; i >= 0; i--) {
		const eb = enemyBullets[i];
		if (eb.x < -50 || eb.x > W + 50 || eb.y < -50 || eb.y > H + 50) enemyBullets.splice(i, 1);
	}

	// 自弾 vs 敵
	for (let i = bullets.length - 1; i >= 0; i--) {
		const b = bullets[i];
		const bBox = { x: b.x - 4, y: b.y - 3, w: 8, h: 6 };
		for (let j = enemies.length - 1; j >= 0; j--) {
			if (!intersects(bBox, enemies[j])) continue;
			enemies[j].hp--;
			bullets.splice(i, 1);
			if (enemies[j].hp <= 0) {
				const e = enemies[j];
				state.score += e.points * state.multi;
				burst(e.x + e.w * 0.5, e.y + e.h * 0.5, e.color, 22);
				if (Math.random() < 0.18) chips.push({ x: e.x, y: e.y, w: 14, h: 14 });
				enemies.splice(j, 1);
				state.multi = Math.min(12, state.multi + 1);
				updateHUD();
			} else {
				// ヒットエフェクト
				burst(b.x, b.y, "#ffffff", 4);
			}
			break;
		}
	}

	// 敵弾 vs プレイヤー
	for (let i = enemyBullets.length - 1; i >= 0; i--) {
		const eb = enemyBullets[i];
		const box = { x: eb.x - 4, y: eb.y - 4, w: 8, h: 8 };
		if (intersects(player, box)) {
			enemyBullets.splice(i, 1);
			hitPlayer();
			break;
		}
	}

	// 敵 vs プレイヤー
	for (let i = enemies.length - 1; i >= 0; i--) {
		if (intersects(player, enemies[i])) {
			burst(enemies[i].x, enemies[i].y, enemies[i].color, 15);
			enemies.splice(i, 1);
			hitPlayer();
			break;
		}
	}

	// チップ（パワーアップ）
	for (const c of chips) c.x -= 170 * dt;
	for (let i = chips.length - 1; i >= 0; i--) {
		if (chips[i].x < -20) { chips.splice(i, 1); continue; }
		if (intersects(player, chips[i])) {
			chips.splice(i, 1);
			player.power = Math.min(3, player.power + 1);
			state.score += 80;
			burst(player.x + player.w * 0.5, player.y + player.h * 0.5, "rgba(83,255,166,0.8)", 12);
			updateHUD();
		}
	}

	// パーティクル
	for (const p of particles) {
		p.life -= dt;
		p.x += p.vx * dt;
		p.y += p.vy * dt;
		p.vx *= 0.95;
		p.vy *= 0.95;
	}
	for (let i = particles.length - 1; i >= 0; i--) {
		if (particles[i].life <= 0) particles.splice(i, 1);
	}

	// 時間経過スコア
	state.score += dt * (10 + state.multi * 2);
	updateHUD();
}

// ===== 描画処理 =====
function draw() {
	ctx.clearRect(0, 0, W, H);

	// 空のグラデーション
	const sky = ctx.createLinearGradient(0, 0, 0, H);
	sky.addColorStop(0, "#080e24");
	sky.addColorStop(0.5, "#0a0f1e");
	sky.addColorStop(1, "#1a100c");
	ctx.fillStyle = sky;
	ctx.fillRect(0, 0, W, H);

	// 星雲
	for (const n of nebulae) {
		n.x -= 0.15;
		if (n.x + n.r < 0) n.x = W + n.r;
		const g = ctx.createRadialGradient(n.x, n.y, 0, n.x, n.y, n.r);
		g.addColorStop(0, "hsla(" + n.hue + ",60%,50%," + n.a + ")");
		g.addColorStop(1, "transparent");
		ctx.fillStyle = g;
		ctx.fillRect(n.x - n.r, n.y - n.r, n.r * 2, n.r * 2);
	}

	// 星
	for (const s of stars) {
		s.x -= s.s;
		if (s.x < -2) { s.x = W + 2; s.y = Math.random() * (GROUND - 10); }
		ctx.globalAlpha = s.a + Math.sin(state.t * 3 + s.x) * 0.15;
		ctx.fillStyle = "#fff";
		ctx.fillRect(s.x, s.y, s.r, s.r);
	}
	ctx.globalAlpha = 1;

	// 地面
	ctx.fillStyle = "#1e120e";
	ctx.fillRect(0, GROUND, W, H - GROUND);
	// 建物シルエット
	ctx.fillStyle = "#2a1f2e";
	for (let i = 0; i < 16; i++) {
		const bx = ((i * 100) - (state.t * 80) % 100) % (16 * 100) - 100;
		const bh = 20 + (i * 37 % 40);
		ctx.fillRect(bx, GROUND - bh, 48, bh);
	}
	// 地面ライン
	ctx.strokeStyle = "rgba(83,255,166,0.15)";
	ctx.lineWidth = 1;
	ctx.beginPath();
	ctx.moveTo(0, GROUND);
	ctx.lineTo(W, GROUND);
	ctx.stroke();

	// チップ
	for (const c of chips) {
		ctx.fillStyle = "#53ffa6";
		ctx.shadowColor = "#53ffa6";
		ctx.shadowBlur = 8;
		ctx.fillRect(c.x, c.y, c.w, c.h);
		ctx.shadowBlur = 0;
		ctx.fillStyle = "rgba(255,255,255,0.85)";
		ctx.fillRect(c.x + 4, c.y + 4, 6, 6);
	}

	// 自弾
	for (const b of bullets) {
		ctx.fillStyle = "#ffe85a";
		ctx.shadowColor = "#ffe85a";
		ctx.shadowBlur = 6;
		ctx.fillRect(b.x - 7, b.y - 1.5, 14, 3);
		ctx.shadowBlur = 0;
	}

	// 敵弾
	for (const eb of enemyBullets) {
		ctx.fillStyle = "#ff6eb4";
		ctx.shadowColor = "#ff6eb4";
		ctx.shadowBlur = 5;
		ctx.beginPath();
		ctx.arc(eb.x, eb.y, 4, 0, Math.PI * 2);
		ctx.fill();
		ctx.shadowBlur = 0;
	}

	// 敵
	for (const e of enemies) {
		ctx.fillStyle = e.color;
		ctx.shadowColor = e.color;
		ctx.shadowBlur = 6;
		ctx.fillRect(e.x, e.y, e.w, e.h);
		ctx.shadowBlur = 0;
		// 目
		ctx.fillStyle = "rgba(0,0,0,0.5)";
		ctx.fillRect(e.x + 5, e.y + 5, 5, 5);
		ctx.fillRect(e.x + e.w - 10, e.y + 5, 5, 5);
		// HPバー
		if (e.hp < e.maxHp) {
			const ratio = e.hp / e.maxHp;
			ctx.fillStyle = "rgba(0,0,0,0.5)";
			ctx.fillRect(e.x, e.y - 6, e.w, 4);
			ctx.fillStyle = ratio > 0.5 ? "#53ffa6" : "#ff4466";
			ctx.fillRect(e.x, e.y - 6, e.w * ratio, 4);
		}
	}

	// パーティクル
	for (const p of particles) {
		ctx.globalAlpha = Math.max(0, p.life);
		ctx.fillStyle = p.color;
		ctx.fillRect(p.x - p.size * 0.5, p.y - p.size * 0.5, p.size, p.size);
	}
	ctx.globalAlpha = 1;

	// プレイヤー
	if (!(player.inv > 0 && Math.floor(player.inv * 18) % 2 === 0)) {
		// 船体
		ctx.fillStyle = "#53ffa6";
		ctx.shadowColor = "#53ffa6";
		ctx.shadowBlur = 10;
		ctx.beginPath();
		ctx.moveTo(player.x + player.w, player.y + player.h * 0.5);
		ctx.lineTo(player.x + 4, player.y);
		ctx.lineTo(player.x + 12, player.y + player.h * 0.5);
		ctx.lineTo(player.x + 4, player.y + player.h);
		ctx.closePath();
		ctx.fill();
		ctx.shadowBlur = 0;
		// エンジン炎
		const flameLen = 6 + Math.random() * 8;
		ctx.fillStyle = Math.random() > 0.5 ? "#ff5533" : "#ffaa22";
		ctx.beginPath();
		ctx.moveTo(player.x + 2, player.y + player.h * 0.35);
		ctx.lineTo(player.x - flameLen, player.y + player.h * 0.5);
		ctx.lineTo(player.x + 2, player.y + player.h * 0.65);
		ctx.closePath();
		ctx.fill();
		// パワーレベル表示（翼の光）
		if (player.power >= 2) {
			ctx.fillStyle = "rgba(83,255,166,0.5)";
			ctx.fillRect(player.x + 8, player.y - 3, 3, 3);
			ctx.fillRect(player.x + 8, player.y + player.h, 3, 3);
		}
		if (player.power >= 3) {
			ctx.fillStyle = "rgba(255,214,102,0.6)";
			ctx.fillRect(player.x + 16, player.y - 5, 3, 3);
			ctx.fillRect(player.x + 16, player.y + player.h + 2, 3, 3);
		}
	}

	// ヒットフラッシュ
	if (state.hitFlash > 0) {
		ctx.fillStyle = "rgba(255,68,102," + (state.hitFlash * 0.3) + ")";
		ctx.fillRect(0, 0, W, H);
	}

	// ウェーブ表示
	ctx.fillStyle = "rgba(255,255,255,0.25)";
	ctx.font = "12px sans-serif";
	ctx.textAlign = "right";
	ctx.fillText("WAVE " + (state.waveLevel + 1), W - 16, 20);
	ctx.textAlign = "left";
}

// ===== ゲームループ =====
let lastTs = 0;
function loop(ts) {
	if (!lastTs) lastTs = ts;
	const dt = Math.min(0.033, (ts - lastTs) / 1000);
	lastTs = ts;
	if (state.started && !state.paused && !state.over) update(dt);
	draw();
	requestAnimationFrame(loop);
}

// ===== ゲーム開始 =====
function startGame() {
	state.started = true;
	state.paused = false;
	state.over = false;
	document.getElementById("startOverlay").classList.remove("show");
	document.getElementById("overOverlay").classList.remove("show");
	document.getElementById("pauseBtn").textContent = "Pause";
}

// ===== キー入力 =====
function setKey(code, v) {
	if (code === "ArrowUp" || code === "KeyW") key.up = v;
	if (code === "ArrowDown" || code === "KeyS") key.down = v;
	if (code === "ArrowLeft" || code === "KeyA") key.left = v;
	if (code === "ArrowRight" || code === "KeyD") key.right = v;
	if (code === "Space" || code === "KeyJ") key.shoot = v;
}

document.addEventListener("keydown", function(e) {
	if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight","Space"].indexOf(e.code) !== -1) e.preventDefault();
	if (!state.started && !state.over) startGame();
	setKey(e.code, true);
	if (e.code === "KeyK") useBomb();
	if (e.code === "KeyP") {
		if (!state.started || state.over) return;
		state.paused = !state.paused;
		document.getElementById("pauseBtn").textContent = state.paused ? "Resume" : "Pause";
	}
	if (e.code === "KeyR") { resetGame(); startGame(); }
}, { passive: false });

document.addEventListener("keyup", function(e) { setKey(e.code, false); });

// iframeフォーカス対応
window.addEventListener("click", function() { window.focus(); });
window.addEventListener("pointerdown", function() { window.focus(); });

// ===== ボタン =====
document.getElementById("startBtn").addEventListener("click", function() { startGame(); });
document.getElementById("retryBtn").addEventListener("click", function() { resetGame(); startGame(); });
document.getElementById("restartBtn").addEventListener("click", function() { resetGame(); startGame(); });
document.getElementById("pauseBtn").addEventListener("click", function() {
	if (!state.started || state.over) return;
	state.paused = !state.paused;
	document.getElementById("pauseBtn").textContent = state.paused ? "Resume" : "Pause";
});

// ===== タッチ対応 =====
document.querySelectorAll("#touch button").forEach(function(btn) {
	const k = btn.dataset.k;
	btn.addEventListener("pointerdown", function(e) {
		e.preventDefault();
		if (!state.started) startGame();
		if (k === "left") key.left = true;
		if (k === "right") key.right = true;
		if (k === "up") key.up = true;
		if (k === "shoot") key.shoot = true;
		if (k === "bomb") useBomb();
	});
	function up() {
		if (k === "left") key.left = false;
		if (k === "right") key.right = false;
		if (k === "up") key.up = false;
		if (k === "shoot") key.shoot = false;
	}
	btn.addEventListener("pointerup", up);
	btn.addEventListener("pointerleave", up);
	btn.addEventListener("pointercancel", up);
});

// ===== 初期化 =====
window.addEventListener("resize", resize);
resize();
resetGame();
requestAnimationFrame(loop);
</script>
</body>
</html>
