<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta name="ai.author" content="Claude">
	<meta name="ai.note" content="This file was generated by Claude.">
	<title>Tetris (Simple) - Claude版</title>
	<style>
		body { margin: 0; background: #111; display: flex; justify-content: center; align-items: flex-start; padding-top: 20px; font-family: sans-serif; }
		canvas { background: #000; display: block; }
		.game-area { display: flex; gap: 20px; }
		.info { color: #aaa; }
		.info h2 { color: #fff; margin: 0 0 10px; }
		.info p { margin: 5px 0; }
		.score { font-size: 2rem; color: #0f0; }
	</style>
</head>
<body>
	<div class="game-area">
		<canvas id="tetris" width="200" height="400"></canvas>
		<div class="info">
			<h2>TETRIS</h2>
			<p class="score" id="score">0</p>
			<p>Lines: <span id="lines">0</span></p>
			<p>Level: <span id="level">1</span></p>
			<hr style="border-color:#333;margin:15px 0">
			<p style="color:#888">← → : 移動</p>
			<p style="color:#888">↓ : 落下</p>
			<p style="color:#888">Q W : 回転</p>
		</div>
	</div>
	<script>
		// Claudeによるシンプルテトリス
		// スコア表示、レベルアップ機能付き
		const canvas = document.getElementById('tetris');
		const ctx = canvas.getContext('2d');
		const W = 10, H = 20, B = 20;
		const arena = Array.from({ length: H }, () => new Array(W).fill(0));

		const colors = [null, '#00f0f0', '#0000f0', '#f0a000', '#f0f000', '#00f000', '#a000f0', '#f00000'];

		const pieces = {
			I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
			J: [[2,0,0],[2,2,2],[0,0,0]],
			L: [[0,0,3],[3,3,3],[0,0,0]],
			O: [[4,4],[4,4]],
			S: [[0,5,5],[5,5,0],[0,0,0]],
			T: [[0,6,0],[6,6,6],[0,0,0]],
			Z: [[7,7,0],[0,7,7],[0,0,0]]
		};

		const player = { pos: { x: 0, y: 0 }, matrix: null };
		let score = 0, lines = 0, level = 1;
		let dropCounter = 0, dropInterval = 500, lastTime = 0;

		function collide(arena, p) {
			for (let y = 0; y < p.matrix.length; y++) {
				for (let x = 0; x < p.matrix[y].length; x++) {
					if (p.matrix[y][x] !== 0) {
						if (!arena[y + p.pos.y] || arena[y + p.pos.y][x + p.pos.x] !== 0) return true;
					}
				}
			}
			return false;
		}

		function merge(arena, p) {
			p.matrix.forEach((row, y) => {
				row.forEach((val, x) => {
					if (val) arena[y + p.pos.y][x + p.pos.x] = val;
				});
			});
		}

		function rotate(matrix, dir) {
			for (let y = 0; y < matrix.length; y++)
				for (let x = 0; x < y; x++)
					[matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
			if (dir > 0) matrix.forEach(r => r.reverse());
			else matrix.reverse();
		}

		function sweep() {
			let cleared = 0;
			outer: for (let y = H - 1; y >= 0; y--) {
				for (let x = 0; x < W; x++) if (arena[y][x] === 0) continue outer;
				arena.splice(y, 1);
				arena.unshift(new Array(W).fill(0));
				y++;
				cleared++;
			}
			if (cleared > 0) {
				const points = [0, 100, 300, 500, 800];
				score += (points[cleared] || 800) * level;
				lines += cleared;
				level = Math.floor(lines / 10) + 1;
				dropInterval = Math.max(100, 500 - (level - 1) * 40);
				document.getElementById('score').textContent = score;
				document.getElementById('lines').textContent = lines;
				document.getElementById('level').textContent = level;
			}
		}

		function resetPlayer() {
			const keys = 'IJLOSTZ';
			const p = keys[Math.floor(Math.random() * keys.length)];
			player.matrix = pieces[p].map(r => [...r]);
			player.pos.y = 0;
			player.pos.x = Math.floor((W - player.matrix[0].length) / 2);
			if (collide(arena, player)) {
				arena.forEach(r => r.fill(0));
				score = 0; lines = 0; level = 1;
				dropInterval = 500;
				document.getElementById('score').textContent = 0;
				document.getElementById('lines').textContent = 0;
				document.getElementById('level').textContent = 1;
			}
		}

		function drop() {
			player.pos.y++;
			if (collide(arena, player)) {
				player.pos.y--;
				merge(arena, player);
				sweep();
				resetPlayer();
			}
			dropCounter = 0;
		}

		function move(dir) {
			player.pos.x += dir;
			if (collide(arena, player)) player.pos.x -= dir;
		}

		function playerRotate(dir) {
			const px = player.pos.x;
			let offset = 1;
			rotate(player.matrix, dir);
			while (collide(arena, player)) {
				player.pos.x += offset;
				offset = -(offset + (offset > 0 ? 1 : -1));
				if (offset > player.matrix[0].length) {
					rotate(player.matrix, -dir);
					player.pos.x = px;
					return;
				}
			}
		}

		function drawMatrix(mat, off) {
			mat.forEach((row, y) => {
				row.forEach((val, x) => {
					if (val) {
						ctx.fillStyle = colors[val];
						ctx.fillRect((x + off.x) * B, (y + off.y) * B, B - 1, B - 1);
					}
				});
			});
		}

		function draw() {
			ctx.fillStyle = '#000';
			ctx.fillRect(0, 0, canvas.width, canvas.height);
			// グリッド線
			ctx.strokeStyle = '#181818';
			for (let x = 0; x <= W; x++) { ctx.beginPath(); ctx.moveTo(x * B, 0); ctx.lineTo(x * B, H * B); ctx.stroke(); }
			for (let y = 0; y <= H; y++) { ctx.beginPath(); ctx.moveTo(0, y * B); ctx.lineTo(W * B, y * B); ctx.stroke(); }
			drawMatrix(arena, { x: 0, y: 0 });
			drawMatrix(player.matrix, player.pos);
		}

		function update(time = 0) {
			dropCounter += time - lastTime;
			lastTime = time;
			if (dropCounter > dropInterval) drop();
			draw();
			requestAnimationFrame(update);
		}

		document.addEventListener('keydown', e => {
			if (e.key === 'ArrowLeft') move(-1);
			else if (e.key === 'ArrowRight') move(1);
			else if (e.key === 'ArrowDown') drop();
			else if (e.key === 'q' || e.key === 'Q') playerRotate(-1);
			else if (e.key === 'w' || e.key === 'W') playerRotate(1);
		});

		resetPlayer();
		update();
	</script>
</body>
</html>
