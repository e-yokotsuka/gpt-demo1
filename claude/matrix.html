<!DOCTYPE html>
<html lang="ja">
<head>
	<meta charset="UTF-8">
	<meta name="ai.author" content="Claude">
	<meta name="ai.note" content="This file was generated by Claude.">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Digital Rain Matrix - Claude版</title>
	<style>
		body { margin: 0; overflow: hidden; background: #000; }
		canvas { display: block; }
	</style>
</head>
<body>
	<canvas id="c"></canvas>
	<script>
		// Claudeによるマトリックスデジタルレイン実装
		// カタカナ文字を使用し、列ごとに異なる速度と明るさを持たせる
		const canvas = document.getElementById('c');
		const ctx = canvas.getContext('2d');
		canvas.width = window.innerWidth;
		canvas.height = window.innerHeight;

		const katakana = 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン';
		const digits = '0123456789';
		const chars = katakana + digits;
		const fontSize = 14;
		const cols = Math.floor(canvas.width / fontSize);

		// 各列の状態管理
		const columns = Array.from({ length: cols }, () => ({
			y: Math.random() * -100,
			speed: Math.random() * 0.5 + 0.3,
			brightness: Math.random() * 0.4 + 0.6,
			chars: Array.from({ length: Math.ceil(canvas.height / fontSize) + 5 }, () =>
				chars[Math.floor(Math.random() * chars.length)]
			)
		}));

		function draw() {
			// 半透明の黒でフェードアウト効果
			ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
			ctx.fillRect(0, 0, canvas.width, canvas.height);

			ctx.font = `${fontSize}px monospace`;

			for (let i = 0; i < cols; i++) {
				const col = columns[i];
				const headY = Math.floor(col.y);

				for (let j = Math.max(0, headY - 20); j <= headY; j++) {
					const screenY = j * fontSize;
					if (screenY < 0 || screenY > canvas.height) continue;

					const charIdx = j % col.chars.length;
					// ランダムにたまに文字を変更
					if (Math.random() < 0.02) {
						col.chars[charIdx] = chars[Math.floor(Math.random() * chars.length)];
					}

					const distFromHead = headY - j;
					if (distFromHead === 0) {
						// 先頭は白く光る
						ctx.fillStyle = '#fff';
					} else if (distFromHead < 3) {
						// 先頭近くは明るい緑
						ctx.fillStyle = `rgba(0, 255, 70, ${col.brightness})`;
					} else {
						// 後続は徐々に暗くなる
						const alpha = Math.max(0, col.brightness - distFromHead * 0.04);
						ctx.fillStyle = `rgba(0, 200, 50, ${alpha})`;
					}

					ctx.fillText(col.chars[charIdx], i * fontSize, screenY);
				}

				col.y += col.speed;

				// 画面外に出たらリセット
				if ((col.y - 25) * fontSize > canvas.height) {
					col.y = Math.random() * -20;
					col.speed = Math.random() * 0.5 + 0.3;
				}
			}

			requestAnimationFrame(draw);
		}

		draw();

		window.addEventListener('resize', () => {
			canvas.width = window.innerWidth;
			canvas.height = window.innerHeight;
		});
	</script>
</body>
</html>
