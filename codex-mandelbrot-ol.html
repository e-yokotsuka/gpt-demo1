<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="ai.author" content="ChatGPT-5.3-Codex">
  <meta name="ai.note" content="This file was generated by ChatGPT-5.3-Codex.">
  <title>Mandelbrot OpenLayers - ChatGPT-5.3-Codex</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/ol@v7.3.0/ol.css">
  <style>
    :root {
      --panel: rgba(6, 12, 27, 0.76);
      --line: rgba(136, 209, 255, 0.34);
      --text: #dceeff;
    }
    html, body {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #02040a;
      color: var(--text);
      font-family: "Segoe UI", Meiryo, sans-serif;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    .hud {
      position: fixed;
      left: 12px;
      top: 12px;
      z-index: 1000;
      border: 1px solid var(--line);
      background: var(--panel);
      border-radius: 10px;
      padding: 9px 10px;
      font-size: 12px;
      min-width: 190px;
      backdrop-filter: blur(4px);
    }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="hud" id="hud">zooming...</div>
  <script src="https://cdn.jsdelivr.net/npm/ol@v7.3.0/dist/ol.js"></script>
  <script>
    const hud = document.getElementById("hud");
    const source = new ol.source.ImageCanvas({
      projection: "EPSG:3857",
      canvasFunction: (extent, resolution, pixelRatio, size) => {
        const canvas = document.createElement("canvas");
        canvas.width = size[0];
        canvas.height = size[1];
        const ctx = canvas.getContext("2d");
        const img = ctx.createImageData(size[0], size[1]);
        const data = img.data;

        const maxIter = 140;
        for (let y = 0; y < size[1]; y++) {
          const wy = extent[3] - y * resolution;
          for (let x = 0; x < size[0]; x++) {
            const wx = extent[0] + x * resolution;

            const cx = wx / 25000000;
            const cy = wy / 25000000;

            let zx = 0;
            let zy = 0;
            let i = 0;
            while (i < maxIter) {
              const xx = zx * zx - zy * zy + cx;
              const yy = 2 * zx * zy + cy;
              zx = xx;
              zy = yy;
              if (zx * zx + zy * zy > 4) break;
              i++;
            }

            const p = (y * size[0] + x) * 4;
            if (i >= maxIter) {
              data[p] = 0; data[p + 1] = 0; data[p + 2] = 0; data[p + 3] = 255;
            } else {
              const t = i / maxIter;
              data[p] = Math.floor(8 * (1 - t) * t * t * t * 255);
              data[p + 1] = Math.floor(12 * (1 - t) * (1 - t) * t * t * 255);
              data[p + 2] = Math.floor(11 * (1 - t) * (1 - t) * (1 - t) * t * 255);
              data[p + 3] = 255;
            }
          }
        }
        ctx.putImageData(img, 0, 0);
        return canvas;
      }
    });

    const layer = new ol.layer.Image({ source });
    const view = new ol.View({
      center: [-18500000, 3300000],
      zoom: 1.6,
      maxZoom: 24
    });

    const map = new ol.Map({
      target: "map",
      layers: [layer],
      controls: [],
      view
    });

    let autoZoom = true;
    document.addEventListener("keydown", (e) => {
      if (e.code === "Space") autoZoom = !autoZoom;
    });

    function step() {
      if (autoZoom) {
        const z = view.getZoom();
        const c = view.getCenter();
        view.setZoom(z + 0.004);
        view.setCenter([c[0] + 50, c[1] - 26]);
        source.changed();
      }
      hud.textContent = "zoom " + view.getZoom().toFixed(3) + " | space: auto " + (autoZoom ? "on" : "off");
      requestAnimationFrame(step);
    }
    step();
  </script>
</body>
</html>
