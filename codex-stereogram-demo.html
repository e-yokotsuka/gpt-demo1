<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="ai.author" content="ChatGPT-5.3-Codex">
  <meta name="ai.note" content="This file was generated by ChatGPT-5.3-Codex.">
  <title>Stereogram Demo - ChatGPT-5.3-Codex</title>
  <style>
    :root {
      --bg: #080b14;
      --panel: rgba(14, 20, 36, 0.84);
      --line: rgba(129, 184, 255, 0.28);
      --text: #dce7ff;
      --muted: #96a8d1;
      --accent: #79dbff;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      min-height: 100vh;
      overflow: hidden;
      background:
        radial-gradient(circle at 16% 10%, rgba(94, 190, 255, 0.2), transparent 36%),
        radial-gradient(circle at 86% 12%, rgba(255, 123, 164, 0.16), transparent 32%),
        var(--bg);
      color: var(--text);
      font-family: "Segoe UI", sans-serif;
    }
    canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    .panel {
      position: fixed;
      left: 12px;
      top: 12px;
      width: min(340px, calc(100vw - 24px));
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 12px;
      backdrop-filter: blur(4px);
      padding: 10px 12px;
    }
    h1 {
      margin: 0 0 8px;
      font-size: 15px;
      color: var(--accent);
      letter-spacing: 0.04em;
    }
    .row {
      display: grid;
      grid-template-columns: 74px 1fr 54px;
      gap: 8px;
      align-items: center;
      margin: 6px 0;
      font-size: 12px;
      color: var(--muted);
    }
    .row output {
      text-align: right;
      color: var(--text);
      font-variant-numeric: tabular-nums;
    }
    .row select {
      grid-column: span 2;
      background: #13203f;
      color: #e7efff;
      border: 1px solid #3a4e7a;
      border-radius: 7px;
      padding: 5px 7px;
      font-size: 12px;
    }
    input[type="range"] {
      width: 100%;
      accent-color: #79dbff;
    }
    .actions {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    button {
      border: 1px solid #3c517f;
      background: #172545;
      color: #eaf2ff;
      border-radius: 8px;
      padding: 7px 11px;
      cursor: pointer;
      font-size: 12px;
    }
    button:hover { background: #1e2f58; }
    .help {
      margin-top: 8px;
      font-size: 11px;
      line-height: 1.5;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <canvas id="view"></canvas>
  <section class="panel">
    <h1>STEREOGRAM DEMO // CODEX 5.3</h1>
    <div class="row">
      <label for="mode">mode</label>
      <select id="mode">
        <option value="orb">Orb</option>
        <option value="wave">Wave</option>
        <option value="g53">G53</option>
      </select>
    </div>
    <div class="row">
      <label for="sep">separation</label>
      <input id="sep" type="range" min="38" max="110" step="1" value="72">
      <output id="sep-v">72</output>
    </div>
    <div class="row">
      <label for="depth">depth</label>
      <input id="depth" type="range" min="8" max="56" step="1" value="26">
      <output id="depth-v">26</output>
    </div>
    <div class="row">
      <label for="speed">speed</label>
      <input id="speed" type="range" min="0" max="100" step="1" value="42">
      <output id="speed-v">42</output>
    </div>
    <div class="actions">
      <button id="btn-noise">New Noise</button>
      <button id="btn-pause">Pause</button>
    </div>
    <div class="help">
      画面中央を見るのではなく、少し遠くを見る感覚で視線をぼかすと立体が浮きます。<br>
      `g53` モードは中央に立体文字が出ます。
    </div>
  </section>

  <script>
    const canvas = document.getElementById("view");
    const ctx = canvas.getContext("2d");
    const W = 480;
    const H = 270;

    const buf = document.createElement("canvas");
    buf.width = W;
    buf.height = H;
    const bctx = buf.getContext("2d", { willReadFrequently: true });
    const img = bctx.createImageData(W, H);
    const px = img.data;

    const depthMap = new Uint8Array(W * H);
    const pattern = new Uint8Array(W * H);
    const row = new Uint8Array(W);

    const textMask = (() => {
      const c = document.createElement("canvas");
      c.width = W;
      c.height = H;
      const t = c.getContext("2d");
      t.fillStyle = "#000";
      t.fillRect(0, 0, W, H);
      t.fillStyle = "#fff";
      t.textAlign = "center";
      t.textBaseline = "middle";
      t.font = "bold 122px Segoe UI";
      t.fillText("G53", W * 0.5, H * 0.5 + 2);
      const d = t.getImageData(0, 0, W, H).data;
      const out = new Uint8Array(W * H);
      for (let i = 0, p = 0; i < d.length; i += 4, p++) out[p] = d[i];
      return out;
    })();

    const ui = {
      mode: document.getElementById("mode"),
      sep: document.getElementById("sep"),
      depth: document.getElementById("depth"),
      speed: document.getElementById("speed"),
      sepV: document.getElementById("sep-v"),
      depthV: document.getElementById("depth-v"),
      speedV: document.getElementById("speed-v"),
      noise: document.getElementById("btn-noise"),
      pause: document.getElementById("btn-pause")
    };

    const state = {
      mode: "orb",
      sep: 72,
      depth: 26,
      speed: 0.42,
      paused: false,
      time: 0
    };

    function reseed() {
      for (let i = 0; i < pattern.length; i++) {
        pattern[i] = (Math.random() * 255) | 0;
      }
    }

    function resize() {
      canvas.width = Math.floor(window.innerWidth * window.devicePixelRatio);
      canvas.height = Math.floor(window.innerHeight * window.devicePixelRatio);
      ctx.setTransform(window.devicePixelRatio, 0, 0, window.devicePixelRatio, 0, 0);
      ctx.imageSmoothingEnabled = false;
    }

    function setFromUI() {
      state.mode = ui.mode.value;
      state.sep = parseInt(ui.sep.value, 10);
      state.depth = parseInt(ui.depth.value, 10);
      state.speed = parseInt(ui.speed.value, 10) / 100;
      ui.sepV.textContent = String(state.sep);
      ui.depthV.textContent = String(state.depth);
      ui.speedV.textContent = String(parseInt(ui.speed.value, 10));
    }

    function clearDepth() {
      depthMap.fill(0);
    }

    function drawOrb(t) {
      const cx = W * (0.5 + Math.sin(t * 0.8) * 0.16);
      const cy = H * (0.5 + Math.cos(t * 0.5) * 0.07);
      const r = 58 + Math.sin(t * 1.2) * 12;
      const r2 = r * r;
      for (let y = 0; y < H; y++) {
        const dy = y - cy;
        const dy2 = dy * dy;
        for (let x = 0; x < W; x++) {
          const dx = x - cx;
          const d2 = dx * dx + dy2;
          if (d2 > r2) continue;
          const n = Math.sqrt(1 - d2 / r2);
          const v = 70 + n * 185;
          const i = y * W + x;
          if (v > depthMap[i]) depthMap[i] = v;
        }
      }
    }

    function drawWave(t) {
      for (let y = 0; y < H; y++) {
        for (let x = 0; x < W; x++) {
          const vx = Math.sin(x * 0.048 + t * 1.3);
          const vy = Math.cos(y * 0.07 - t * 1.8);
          const v = ((vx + vy) * 0.5 + 1) * 128;
          depthMap[y * W + x] = v | 0;
        }
      }
      drawOrb(t * 0.7);
    }

    function drawG53(t) {
      const bob = Math.sin(t * 1.4) * 26;
      for (let i = 0; i < depthMap.length; i++) {
        const m = textMask[i];
        if (!m) continue;
        const glow = 80 + m * 0.68 + bob;
        depthMap[i] = glow > 255 ? 255 : glow;
      }
      drawOrb(t * 0.55);
    }

    function buildDepth(t) {
      clearDepth();
      if (state.mode === "orb") drawOrb(t);
      else if (state.mode === "wave") drawWave(t);
      else drawG53(t);
    }

    function renderStereo() {
      const sep = state.sep;
      const depthScale = state.depth / 255;

      for (let y = 0; y < H; y++) {
        const o = y * W;
        for (let x = 0; x < W; x++) {
          if (x < sep) {
            row[x] = pattern[o + x];
            continue;
          }
          const d = depthMap[o + x];
          const shift = (d * depthScale) | 0;
          const src = x - sep + shift;
          row[x] = src >= 0 ? row[src] : pattern[o + x];
        }

        for (let x = 0; x < W; x++) {
          const n = row[x];
          const p = (o + x) * 4;
          const c = 92 + ((n * 143) >> 8);
          px[p] = c;
          px[p + 1] = 130 + ((n * 80) >> 8);
          px[p + 2] = 190 + ((n * 60) >> 8);
          px[p + 3] = 255;
        }
      }

      bctx.putImageData(img, 0, 0);
    }

    function drawToScreen() {
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const scale = Math.min(vw / W, vh / H);
      const dw = Math.floor(W * scale);
      const dh = Math.floor(H * scale);
      const dx = (vw - dw) >> 1;
      const dy = (vh - dh) >> 1;

      ctx.clearRect(0, 0, vw, vh);
      ctx.drawImage(buf, dx, dy, dw, dh);
    }

    let last = performance.now();
    function tick(now) {
      const dt = Math.min(0.033, (now - last) / 1000);
      last = now;
      if (!state.paused) state.time += dt * (0.45 + state.speed * 2.1);
      buildDepth(state.time);
      renderStereo();
      drawToScreen();
      requestAnimationFrame(tick);
    }

    ui.mode.addEventListener("change", setFromUI);
    ui.sep.addEventListener("input", setFromUI);
    ui.depth.addEventListener("input", setFromUI);
    ui.speed.addEventListener("input", setFromUI);
    ui.noise.addEventListener("click", reseed);
    ui.pause.addEventListener("click", () => {
      state.paused = !state.paused;
      ui.pause.textContent = state.paused ? "Resume" : "Pause";
    });
    window.addEventListener("resize", resize);

    reseed();
    resize();
    setFromUI();
    requestAnimationFrame(tick);
  </script>
</body>
</html>
