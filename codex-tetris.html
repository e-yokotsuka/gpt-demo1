<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="ai.author" content="ChatGPT-5.3-Codex">
  <meta name="ai.note" content="This file was generated by ChatGPT-5.3-Codex.">
  <title>Tetris (PixiJS) - ChatGPT-5.3-Codex</title>
  <style>
    html, body { margin: 0; height: 100%; background: #060910; overflow: hidden; }
    #app {
      width: 100%;
      height: 100%;
      display: grid;
      place-items: center;
      background:
        radial-gradient(circle at 15% 12%, rgba(80, 180, 255, 0.2), transparent 42%),
        radial-gradient(circle at 88% 16%, rgba(255, 100, 200, 0.18), transparent 40%),
        linear-gradient(150deg, #060910, #0c1430);
    }
    canvas { max-width: 100%; max-height: 100%; display: block; }
  </style>
</head>
<body>
  <div id="app"></div>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.3/pixi.min.js"></script>
  <script>
    const COLS = 10;
    const ROWS = 20;
    const CELL = 32;
    const BOARD_X = 26;
    const BOARD_Y = 26;
    const BOARD_W = COLS * CELL;
    const BOARD_H = ROWS * CELL;
    const SIDE_W = 220;
    const APP_W = BOARD_W + SIDE_W + 58;
    const APP_H = BOARD_H + 52;

    const app = new PIXI.Application({
      width: APP_W,
      height: APP_H,
      backgroundAlpha: 0,
      antialias: true
    });
    document.getElementById("app").appendChild(app.view);

    const root = new PIXI.Container();
    app.stage.addChild(root);

    const boardBack = new PIXI.Graphics();
    boardBack.beginFill(0x071022, 0.92);
    boardBack.drawRoundedRect(BOARD_X - 8, BOARD_Y - 8, BOARD_W + 16, BOARD_H + 16, 12);
    boardBack.endFill();
    root.addChild(boardBack);

    const panelBack = new PIXI.Graphics();
    panelBack.beginFill(0x0a152c, 0.88);
    panelBack.drawRoundedRect(BOARD_X + BOARD_W + 16, BOARD_Y - 8, SIDE_W, BOARD_H + 16, 12);
    panelBack.endFill();
    root.addChild(panelBack);

    const gridG = new PIXI.Graphics();
    const fixedG = new PIXI.Graphics();
    const ghostG = new PIXI.Graphics();
    const activeG = new PIXI.Graphics();
    const fxG = new PIXI.Graphics();
    root.addChild(gridG, fixedG, ghostG, activeG, fxG);
    const overlayLayer = new PIXI.Container();
    root.addChild(overlayLayer);

    const textStyle = new PIXI.TextStyle({ fontFamily: "Segoe UI", fontSize: 18, fill: 0xe8f0ff, fontWeight: "700" });
    const smallStyle = new PIXI.TextStyle({ fontFamily: "Segoe UI", fontSize: 13, fill: 0x98abd8 });

    const title = new PIXI.Text("TETRIS // CODEX 5.3", new PIXI.TextStyle({ fontFamily: "Segoe UI", fontSize: 20, fill: 0x7fd6ff, fontWeight: "800" }));
    title.position.set(BOARD_X + BOARD_W + 26, BOARD_Y + 12);
    root.addChild(title);

    const scoreT = new PIXI.Text("Score\n0", textStyle);
    scoreT.position.set(BOARD_X + BOARD_W + 26, BOARD_Y + 62);
    root.addChild(scoreT);

    const linesT = new PIXI.Text("Lines\n0", textStyle);
    linesT.position.set(BOARD_X + BOARD_W + 26, BOARD_Y + 130);
    root.addChild(linesT);

    const levelT = new PIXI.Text("Level\n1", textStyle);
    levelT.position.set(BOARD_X + BOARD_W + 26, BOARD_Y + 198);
    root.addChild(levelT);

    const nextLabel = new PIXI.Text("Next", textStyle);
    nextLabel.position.set(BOARD_X + BOARD_W + 26, BOARD_Y + 272);
    root.addChild(nextLabel);

    const holdLabel = new PIXI.Text("Hold", textStyle);
    holdLabel.position.set(BOARD_X + BOARD_W + 26, BOARD_Y + 390);
    root.addChild(holdLabel);

    const hint = new PIXI.Text(
      "Move: \u2190 \u2192\nRotate: \u2191 / X / Z\nSoft Drop: \u2193\nHard Drop: Space\nHold: C\nPause: P\nRestart: R",
      smallStyle
    );
    hint.position.set(BOARD_X + BOARD_W + 26, BOARD_Y + 510);
    root.addChild(hint);

    const msg = new PIXI.Text("Press Enter to Start", new PIXI.TextStyle({ fontFamily: "Segoe UI", fontSize: 34, fill: 0xffffff, fontWeight: "800" }));
    msg.anchor.set(0.5);
    msg.position.set(BOARD_X + BOARD_W * 0.5, BOARD_Y + BOARD_H * 0.5);
    root.addChild(msg);

    const pausedMask = new PIXI.Graphics();
    pausedMask.beginFill(0x02050f, 0.72);
    pausedMask.drawRect(BOARD_X, BOARD_Y, BOARD_W, BOARD_H);
    pausedMask.endFill();
    pausedMask.visible = false;
    overlayLayer.addChild(pausedMask);

    const pausedText = new PIXI.Text("PAUSED", new PIXI.TextStyle({ fontFamily: "Segoe UI", fontSize: 46, fill: 0xffffff, fontWeight: "900" }));
    pausedText.anchor.set(0.5);
    pausedText.position.set(BOARD_X + BOARD_W * 0.5, BOARD_Y + BOARD_H * 0.5);
    pausedText.visible = false;
    overlayLayer.addChild(pausedText);

    const board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    const bag = [];
    const nextQueue = [];
    const flashRows = [];

    const COLORS = [0x000000, 0x5ce1ff, 0x4f77ff, 0xffb14c, 0xffee58, 0x55ff96, 0xbd6dff, 0xff5f7a];
    const SHAPES = {
      I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
      J: [[2,0,0],[2,2,2],[0,0,0]],
      L: [[0,0,3],[3,3,3],[0,0,0]],
      O: [[4,4],[4,4]],
      S: [[0,5,5],[5,5,0],[0,0,0]],
      T: [[0,6,0],[6,6,6],[0,0,0]],
      Z: [[7,7,0],[0,7,7],[0,0,0]]
    };

    const state = {
      running: false,
      paused: false,
      over: false,
      score: 0,
      lines: 0,
      level: 1,
      dropTimer: 0,
      dropInterval: 900,
      lockDelay: 0,
      active: null,
      hold: null,
      holdLocked: false
    };

    function clone(matrix) { return matrix.map((r) => [...r]); }

    function refillBag() {
      const pieces = ["I", "J", "L", "O", "S", "T", "Z"];
      for (let i = pieces.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [pieces[i], pieces[j]] = [pieces[j], pieces[i]];
      }
      bag.push(...pieces);
    }

    function nextType() {
      if (bag.length === 0) refillBag();
      return bag.shift();
    }

    function makePiece(type) {
      const matrix = clone(SHAPES[type]);
      return { type, matrix, x: Math.floor((COLS - matrix[0].length) / 2), y: -1 };
    }

    function resetBoard() {
      for (let y = 0; y < ROWS; y++) board[y].fill(0);
      flashRows.length = 0;
      bag.length = 0;
      nextQueue.length = 0;
      for (let i = 0; i < 5; i++) nextQueue.push(nextType());
    }

    function collide(piece, dx = 0, dy = 0, testMatrix = null) {
      const m = testMatrix || piece.matrix;
      for (let y = 0; y < m.length; y++) {
        for (let x = 0; x < m[y].length; x++) {
          if (!m[y][x]) continue;
          const nx = piece.x + x + dx;
          const ny = piece.y + y + dy;
          if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
          if (ny >= 0 && board[ny][nx]) return true;
        }
      }
      return false;
    }

    function rotateMatrix(m, dir) {
      const n = m.length;
      const res = Array.from({ length: n }, () => Array(n).fill(0));
      for (let y = 0; y < n; y++) {
        for (let x = 0; x < n; x++) {
          res[y][x] = dir > 0 ? m[n - 1 - x][y] : m[x][n - 1 - y];
        }
      }
      return res;
    }

    function spawnPiece() {
      state.active = makePiece(nextQueue.shift());
      nextQueue.push(nextType());
      state.holdLocked = false;
      if (collide(state.active, 0, 0)) {
        state.over = true;
        state.running = false;
        msg.text = "Game Over\nPress R";
        msg.style.align = "center";
        msg.visible = true;
      }
    }

    function mergePiece() {
      const p = state.active;
      for (let y = 0; y < p.matrix.length; y++) {
        for (let x = 0; x < p.matrix[y].length; x++) {
          if (!p.matrix[y][x]) continue;
          const by = p.y + y;
          const bx = p.x + x;
          if (by >= 0 && by < ROWS && bx >= 0 && bx < COLS) board[by][bx] = p.matrix[y][x];
        }
      }
    }

    function clearLines() {
      let cleared = 0;
      for (let y = ROWS - 1; y >= 0; y--) {
        if (board[y].every((v) => v !== 0)) {
          flashRows.push({ y, life: 0.12 });
          board.splice(y, 1);
          board.unshift(Array(COLS).fill(0));
          cleared++;
          y++;
        }
      }
      if (!cleared) return;
      const add = [0, 100, 300, 500, 800][cleared] * state.level;
      state.score += add;
      state.lines += cleared;
      state.level = Math.floor(state.lines / 10) + 1;
      state.dropInterval = Math.max(90, 900 - (state.level - 1) * 70);
      refreshHUD();
    }

    function hardDrop() {
      if (!state.active || state.over || state.paused || !state.running) return;
      let moved = 0;
      while (!collide(state.active, 0, 1)) {
        state.active.y += 1;
        moved++;
      }
      state.score += moved * 2;
      lockPiece();
      refreshHUD();
    }

    function lockPiece() {
      mergePiece();
      clearLines();
      spawnPiece();
      state.dropTimer = 0;
      state.lockDelay = 0;
    }

    function hold() {
      if (state.holdLocked || !state.running || state.over) return;
      const cur = state.active.type;
      if (!state.hold) {
        state.hold = cur;
        spawnPiece();
      } else {
        const tmp = state.hold;
        state.hold = cur;
        state.active = makePiece(tmp);
      }
      state.holdLocked = true;
    }

    function refreshHUD() {
      scoreT.text = `Score\n${Math.floor(state.score)}`;
      linesT.text = `Lines\n${state.lines}`;
      levelT.text = `Level\n${state.level}`;
    }

    function startGame() {
      resetBoard();
      state.running = true;
      state.paused = false;
      state.over = false;
      state.score = 0;
      state.lines = 0;
      state.level = 1;
      state.dropInterval = 900;
      state.dropTimer = 0;
      state.hold = null;
      state.holdLocked = false;
      refreshHUD();
      spawnPiece();
      msg.visible = false;
    }

    function drawBlock(g, x, y, color, alpha = 1) {
      const px = BOARD_X + x * CELL;
      const py = BOARD_Y + y * CELL;
      g.beginFill(color, alpha);
      g.drawRoundedRect(px + 1, py + 1, CELL - 2, CELL - 2, 6);
      g.endFill();
      g.beginFill(0xffffff, alpha * 0.18);
      g.drawRoundedRect(px + 4, py + 4, CELL - 8, 8, 4);
      g.endFill();
    }

    function drawGrid() {
      gridG.clear();
      gridG.lineStyle(1, 0x203051, 0.55);
      for (let x = 0; x <= COLS; x++) {
        gridG.moveTo(BOARD_X + x * CELL, BOARD_Y);
        gridG.lineTo(BOARD_X + x * CELL, BOARD_Y + BOARD_H);
      }
      for (let y = 0; y <= ROWS; y++) {
        gridG.moveTo(BOARD_X, BOARD_Y + y * CELL);
        gridG.lineTo(BOARD_X + BOARD_W, BOARD_Y + y * CELL);
      }
    }

    function drawFixed() {
      fixedG.clear();
      for (let y = 0; y < ROWS; y++) {
        for (let x = 0; x < COLS; x++) {
          const v = board[y][x];
          if (v) drawBlock(fixedG, x, y, COLORS[v], 1);
        }
      }
      for (let i = flashRows.length - 1; i >= 0; i--) {
        const f = flashRows[i];
        f.life -= app.ticker.deltaMS / 1000;
        if (f.life <= 0) flashRows.splice(i, 1);
        else {
          const a = Math.min(1, f.life * 8);
          fixedG.beginFill(0xffffff, a * 0.7);
          fixedG.drawRect(BOARD_X, BOARD_Y + f.y * CELL, BOARD_W, CELL);
          fixedG.endFill();
        }
      }
    }

    function getGhostY(piece) {
      let gy = piece.y;
      while (!collide(piece, 0, gy - piece.y + 1)) gy += 1;
      return gy;
    }

    function drawActive() {
      activeG.clear();
      ghostG.clear();
      if (!state.active) return;

      const p = state.active;
      const gy = getGhostY(p);
      for (let y = 0; y < p.matrix.length; y++) {
        for (let x = 0; x < p.matrix[y].length; x++) {
          const v = p.matrix[y][x];
          if (!v) continue;
          const by = gy + y;
          if (by >= 0) drawBlock(ghostG, p.x + x, by, COLORS[v], 0.22);
        }
      }
      for (let y = 0; y < p.matrix.length; y++) {
        for (let x = 0; x < p.matrix[y].length; x++) {
          const v = p.matrix[y][x];
          if (!v) continue;
          const by = p.y + y;
          if (by >= 0) drawBlock(activeG, p.x + x, by, COLORS[v], 1);
        }
      }
    }

    function drawMini(matrix, ox, oy, g) {
      for (let y = 0; y < matrix.length; y++) {
        for (let x = 0; x < matrix[y].length; x++) {
          const v = matrix[y][x];
          if (!v) continue;
          g.beginFill(COLORS[v], 1);
          g.drawRoundedRect(ox + x * 18, oy + y * 18, 16, 16, 4);
          g.endFill();
        }
      }
    }

    function drawPreview() {
      fxG.clear();
      if (nextQueue[0]) drawMini(SHAPES[nextQueue[0]], BOARD_X + BOARD_W + 30, BOARD_Y + 312, fxG);
      if (state.hold) drawMini(SHAPES[state.hold], BOARD_X + BOARD_W + 30, BOARD_Y + 430, fxG);
      pausedMask.visible = state.paused;
      pausedText.visible = state.paused;
    }

    function rotateActive(dir) {
      const p = state.active;
      const rotated = rotateMatrix(p.matrix, dir);
      const kicks = [0, -1, 1, -2, 2];
      for (const dx of kicks) {
        if (!collide(p, dx, 0, rotated)) {
          p.x += dx;
          p.matrix = rotated;
          return;
        }
      }
    }

    function update(dt) {
      if (!state.running || state.paused || state.over) return;
      state.dropTimer += dt;

      if (state.dropTimer >= state.dropInterval / 1000) {
        state.dropTimer = 0;
        if (!collide(state.active, 0, 1)) {
          state.active.y += 1;
        } else {
          lockPiece();
        }
      }
    }

    document.addEventListener("keydown", (e) => {
      if (["ArrowLeft","ArrowRight","ArrowDown","ArrowUp","Space"].includes(e.code)) e.preventDefault();
      if (e.code === "Enter" && !state.running) { startGame(); return; }
      if (e.code === "KeyR") { startGame(); return; }
      if (!state.running || state.over) return;
      if (e.code === "KeyP") { state.paused = !state.paused; return; }
      if (state.paused) return;

      if (e.code === "ArrowLeft") {
        if (!collide(state.active, -1, 0)) state.active.x -= 1;
      } else if (e.code === "ArrowRight") {
        if (!collide(state.active, 1, 0)) state.active.x += 1;
      } else if (e.code === "ArrowDown") {
        if (!collide(state.active, 0, 1)) {
          state.active.y += 1;
          state.score += 1;
          refreshHUD();
        }
      } else if (e.code === "ArrowUp" || e.code === "KeyX") {
        rotateActive(1);
      } else if (e.code === "KeyZ") {
        rotateActive(-1);
      } else if (e.code === "Space") {
        hardDrop();
      } else if (e.code === "KeyC") {
        hold();
      }
    }, { passive: false });

    function fit() {
      const pad = 12;
      const s = Math.min((window.innerWidth - pad * 2) / APP_W, (window.innerHeight - pad * 2) / APP_H);
      root.scale.set(Math.max(0.6, s));
      root.x = (app.renderer.width - APP_W * root.scale.x) * 0.5;
      root.y = (app.renderer.height - APP_H * root.scale.y) * 0.5;
    }

    window.addEventListener("resize", () => {
      app.renderer.resize(window.innerWidth, window.innerHeight);
      fit();
    });

    app.renderer.resize(window.innerWidth, window.innerHeight);
    fit();
    drawGrid();
    refreshHUD();

    app.ticker.add(() => {
      const dt = Math.min(0.033, app.ticker.deltaMS / 1000);
      update(dt);
      drawFixed();
      drawActive();
      drawPreview();
    });
  </script>
</body>
</html>
